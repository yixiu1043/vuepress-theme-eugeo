---
title: 计算机组成与系统结构
date: 2022-10-20
tags:
  - 网课
category: 计算机
banner: /img/banner/62.jpeg
---

#  计算机组成与系统结构

组成：硬件 + 软件

fortram

pascal

c++

java



## 第一章
### 计算机硬件的基本组成

#### 组成

- 运算器+控制器，简称CPU

- 主存储器
- 输入+输出设备



主机：主存储器+CPU

存储器：主存+辅存

I/O设备：输入+输出设备



#### 存储器

- 存储体
- MAR，存储地址寄存器（Memory Address Register） 
- MDR，存储数据寄存器（Memory Data Register）

存储单元：每个存储单元存放一串二进制代码

存储字（word）：存储单元中二进制代码的组合

存储字长：存储单元中二进制代码的位数 8｜16 ｜ 32 ｜64

存储元：存储二进制的电子元件，每个存储元可存 1bit

MAR=4位 -> 总共有2**4个存储单元

MDR=16位 -> 每个存储单元可存放16bit，1个字（word）=16bit

1个字节（Byte）= 8bit

1B = 1个字节，1b=1个bit



#### 运算器

ACC 累加器 Accumulator

MQ 乘商寄存器 Multiple-Quotient Register

X 通用操作数寄存器 

ALU 算数逻辑单元，核心部件 Arithmetic And Logic Unit



#### 控制器

CU 控制单元 Control Unit

IR 指令寄存器 Instruction Register

PC 程序计数器 Program Center

 PC -> IR -> CU

取指令  PC 

分析指令 IR

执行指令 CU



### 计算机系统的层次结构

虚拟机语言 M4（高级语言机器）

虚拟机器 M3 （汇编语言机器）

虚拟机器 M2（操作系统机器）

传统机器 M1（用机器语言的机器）

微程序机器 M0 （微指令系统）



三个级别的语言:

- 高级语言
- 汇编语言
- 机器语言

两种语言类型：

- 编译型语言（一次性全部翻译为汇编语言）
- 解释型语言（翻译一句，执行一句）



### 计算机性能指标

#### 存储器的性能指标

总容量 = 存储单元个数x存储字长

例子：

MAR为32位，MDR为8位

总容量 = 2 \** 32 \* 8bit= 4GB

IByte = 8bit



#### CPU的性能指标

CPU主频：CPU内数字脉冲信号振荡的频率

CPU主频（时钟频率）= 1 / CPU时钟周期



CPI（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数



CPU执行时间（整个程序的耗时）= CPU时钟周期数 / 主频 = （指令条数 * CPI）/ 主频



IPS（Instruction Per Second）：每秒执行多少条指令

IPS = 主频 / 平均CPI



FLOPS（Floating-point Operations Per Second）：每秒执行多少次浮点运算



#### 系统整理的性能指标

数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）

吞吐量：指系统在单位时间内处理请求的数量。

响应时间：用户向计算机发送请求，到系统对该请求做出响应并获得所需结果的等待时间



#### 动态测试

基准程序

使用跑分软件进行动态测试



## 第二章
### 进位计数制

#### 进制转换

真值：符合人类习惯的数字

机器数：数字实际存到机器里的形式，正负号需要被“数字化”



##### r进制：

K<sub>n</sub>K<sub>n-1</sub>...K<sub>2</sub>K<sub>1</sub>K<sub>0</sub>K<sub>-1</sub>K<sub>-2</sub>...K<sub>-m</sub>

= K<sub>n</sub>✖️r<sup>n</sup>➕K<sub>n-1</sub>✖️r<sup>n-1</sup>➕...➕K<sub>2</sub>✖️r<sup>2</sup>➕K<sub>1</sub>✖️r<sup>1</sup>➕K<sub>0</sub>✖️r<sup>0</sup>➕K<sub>-1</sub>✖️r<sup>-1</sup>➕K<sub>-2</sub>✖️r<sup>-2</sup>➕...➕K<sub>-m</sub>✖️r<sup>-m</sup>

基数：每个数码位所用到的不同符号的个数，R进制的基数为R，二进制为2，十进制为10。

位权（r<sup>n</sup>）：由符号处的位置所确定的权值权重。



##### 任意进制转十进制

例子：

将二进制1001 0010.110转化为十进制。

1001 0010.110 

= 1 * 2<sup>7</sup> +  0 * 2<sup>6</sup> +  0 * 2<sup>5</sup> +  1 * 2<sup>4</sup> +  0 * 2<sup>3</sup> +  0 * 2<sup>2</sup> +  1 * 2<sup>1</sup> +  0 * 2<sup>0</sup> +  1 * 2<sup>-1</sup>  +  1 * 2<sup>-2</sup> +  0 * 2<sup>-3</sup> 

= 128 + 16 + 2 + 0.5 + 0.25

= 146.75

| 2<sup>7</sup> | 2<sup>6</sup> | 2<sup>5</sup> | 2<sup>4</sup> | 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 2<sup>-1</sup> | 2<sup>-2</sup> | 2<sup>-3</sup> |
| ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | -------------- | -------------- | -------------- |
| 128           | 64            | 32            | 16            | 8             | 4             | 2             | 1             | 0.5            | 0.25           | 0.125          |
| 1             | 0             | 0             | 1             | 0             | 0             | 1             | 0             | 1              | 1              | 0              |

##### 二进制转八进制
如：1111 0000 10.0110 01

3位一组，不够补0，每组转换成对应的八进制符号

| 001 | 111 | 000 | 010 | .   | 011 | 010 |
| --- | --- | --- | --- | --- | --- | --- |
| 1   | 7   | 0   | 2   | .   | 3   | 2   |

结果：1702.32

##### 二进制转十六进制
如：1111 0000 10.0110 01

4位一组，不够补0，每组转换成对应的十六进制符号

| 0011 | 1100 | 0010 | .   | 0110 | 1000 |
| ---- | ---- | ---- | --- | ---- | ---- |
| 3    | C    | 2    | .   | 6    | 8    |

结果：3C2.68



#### 各种进制的常见书写方式

二进制：(1010)<sub>2</sub> 		1010B

八进制：(1652)<sub>8</sub> 

十进制：(1652)<sub>10</sub> 		1652D

十六进制：(1652)<sub>16</sub> 		1652H 	0x1652



#### 十进制转任意进制

如：75.3		

整数部分=75

##### 除基取余法
$$
K_n*r^n+K_{n-1}*r^{n-1}+...+K_2*r^2+K_1*r^1+K_0*r^0 = 75 {, 根据r进制可得}
$$

$$
\frac {K_n*r^n+K_{n-1}*r^{n-1}+...+K_2*r^2+K_1*r^1+K_0*r^0} {r} 
= K_n*r^{n-1}+K_{n-1}*r^{n-2}+...+K_2*r^1+K_1*r^0...K_0 {，前面部分是商，K_0是余数}
$$

$$
\frac {K_n*r^{n-1}+K_{n-1}*r^{n-2}+...+K_2*r^1+K_1*r^0} {r} 
= K_n*r^{n-2}+K_{n-1}*r^{n-3}+...+K_2*r^0...K_1 {，前面部分是商，K_1是余数}
$$

把商记做x，则： r * x  + K<sub>0</sub>

(r * x  + K<sub>0</sub>) / r，余 K<sub>0</sub> 。



小数部分=0.3

##### 乘基取整法
$$
(K_{-1}*r^{-1}+K_{-2}*r^{-2}+...+K_{-m}*r^{-m}) * r
= K_{-1}*r^0+K_{-2}*r^{-1}+...+K_{-m}*r^{-(m+1)} {，K_{-1}*r^0为整数}
$$

$$
(K_{-2}*r^{-1}+...+K_{-m}*r^{-(m+1)}) * r
= K_{-2}*r^0+...+K_{-m}*r^{-(m+2)} {，K_{-2}*r^0为整数}
$$



#### 十进制转二进制
##### 除基取余法
基数r = 2

整数部分=75

75 ➗ 2 = 37 ... 1,  (K<sub>0</sub> )

37 ➗ 2 = 18 ... 1,  (K<sub>1</sub> )

18 ➗ 2 = 9 ... 0,  (K<sub>2</sub> )

9 ➗ 2 = 4 ... 1,  (K<sub>3</sub>)

4 ➗ 2 = 2 ... 0,  (K<sub>4</sub>)

2 ➗ 2 = 1 ... 0,  (K<sub>5</sub>)

1 ➗ 2 = 0 ... 1,  (K<sub>6</sub>)

最后得：75D = 1001011B



小数部分=0.3

0.3✖️2 = 0.6 = 0 + 0.6 , (K<sub>-1</sub> )

0.6✖️2 = 1.2 = 1 + 0.2 , (K<sub>-2</sub> )

0.2✖️2 = 0.4 = 0 + 0.4 , (K<sub>-3</sub> )

0.4✖️2 = 0.8 = 0 + 0.8 , (K<sub>-4</sub> )

0.8✖️2 = 1.6 = 1 + 0.6 , (K<sub>-5</sub> )

...

无法精确表示

最后得：0.3D = 0.01001B



75.3D = 1001011.01001B



##### 拼凑法

| 2<sup>12</sup> | 2<sup>11</sup> | 2<sup>10</sup> | 2<sup>9</sup> | 2<sup>8</sup> | 2<sup>7</sup> | 2<sup>6</sup> | 2<sup>5</sup> | 2<sup>4</sup> | 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 2<sup>-1</sup> | 2<sup>-2</sup> | 2<sup>-3</sup> |
| -------------- | -------------- | -------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | -------------- | -------------- | -------------- |
| 4096           | 2048           | 1024           | 512           | 256           | 128           | 64            | 32            | 16            | 8             | 4             | 2             | 1             | 0.5            | 0.25           | 0.125          |
| 260.75         |                |                |               | 1             | 0             | 0             | 0             | 0             | 0             | 1             | 0             | 0.            | 1              | 1              |                |
| 533.125        |                |                | 1             | 0             | 0             | 0             | 0             | 1             | 0             | 1             | 0             | 1.            | 0              | 0              | 1              |

例子：

将十进制260.75，533.125转为二进制

260.75 = 256 + 4 + 0.5 + 0.25 = 1000 0010 0.11

533.125 = 512 + 16 + 4 + 1 + 0.125 = 1000 0101 01.001



#### 十进制转八进制

r = 8

与转二进制的方法相同



### BCD码

定义：Binary-Coded Decimal，用二进制编码的十进制

作用：方便人类进行转换

原理：用4个二进制位表示1个十进制字符。



#### 8421码

有权码

| 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 权重              |
| ------------- | ------------- | ------------- | ------------- | ----------------- |
| 8             | 4             | 2             | 1             | 真值              |
| x             | x             | x             | x             | 4个比特位         |
| 0             | 1             | 0             | 1             | 5 = 4 + 1 = 0101B |
| 1             | 0             | 0             | 1             | 9 = 8 + 1 = 1001B |

8421码映射表

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

例子：985

9 = 1001

8 = 1000

5 = 0101

985D = 1001 1000 0101B

 

##### 计算机如何使用8421码进行加法

计算机用8421码得出13的二进制的步骤

8421码中1010-1111没有定义

13不在8421码范围内，计算机要做加6处理

十进制：     5      +        8      =    13

8421码：

1. 0101   +     1000   =    1101（不在8421表中）
2. 1101   +     0110（8421表中的6）   =    10011 
3. =   0001 0011（高位补0）



#### 余3码

无权码

在8421码的基础上加3得来

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |



#### 2421码

| 2<sup>1</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 权重                  |
| ------------- | ------------- | ------------- | ------------- | --------------------- |
| 2             | 4             | 2             | 1             | 真值                  |
| x             | x             | x             | x             | 4个比特位             |
| 0             | 0             | 1             | 1             | 3 = 2 + 1 = 0011B     |
| 1             | 0             | 1             | 1             | 5 = 2 + 2 + 1 = 1101B |

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |

2421码规定：

0～4编码以0开头，5以后的数字以1开头。



### 字符与字符串

ASCII码

可印刷字符：32-126

其余为控制、通信字符：0-31，127

汉字编码



### 奇偶校验码

码距



### 海明校验码

纠错能力

检错能力



### 循环冗余校验码 CRC码

约定除数，检验余数



### 定点数的表示

定点数：小数点的位置固定，例如：996.007    --常规计数

浮点数：小数点的位置不固定，例如；9.96007✖️10<sup>2</sup>  -- 科学计数法



#### 无符号数

定义：整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。

表示范围：

前提条件，用多少个比特位表示。

8位二进制数：2<sup>8</sup>种不同的状态 0000 0000 ～ 1111 1111（0 ～ 255）

n位的无符号数表示范围为：0～2<sup>n-1</sup>

*无符号数只能表示整数，不能表示小数。*



#### 有符号数

有符号位

##### 定点整数

| 符号位 | 数  | 值  | 部  | 分  | 小数点（隐含） |
| ------ | --- | --- | --- | --- | -------------- |
| x      | x   | x   | x   | x   | .              |

##### 定点小数

| 符号位 | 小数点（隐含） | 数  | 值  | 部  | 分  |
| ------ | -------------- | --- | --- | --- | --- |
| x      | .              | x   | x   | x   | x   |

用定点的方式表示19.75，则需要分别保存整数部分和小数部分。

用来表示数值部分的二进制位也称作“尾数”。

用[x]<sub>原</sub>、[x]<sub>反</sub>、[x]<sub>补</sub>、[x]<sub>移</sub>的书写方式来表示x的原码、反码、补码、移码。

#### 原码

用尾数表示真值的绝对值，符号位“0/1”对应“正/负”。

*若机器字长为 n+1 位，则尾数占 n 位。*

定点整数的表示范围：-(2<sup>n</sup> - 1) ~ 2<sup>n</sup> - 1

定点小数的表示范围：-(1 - 2<sup>-n</sup> ) ~ 1 - 2<sup>-n</sup>

 真值0有 +0 和 -0 两种形式。

如机器字长为8位。

| 符号 | 2<sup>6</sup> | 2<sup>5</sup> | 2<sup>4</sup> | 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> |                               |
| ---- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ----------------------------- |
| 0    | 0             | 0             | 1             | 0             | 0             | 1             | 1             | +19D = 16 + 2 + 1 = 0001 0011 |
| 1    | 0             | 0             | 1             | 0             | 0             | 1             | 1             | -19D = 16 + 2 + 1 = 1001 0011 |

| 符号 | 2<sup>-1</sup> | 2<sup>-2</sup> | 2<sup>-3</sup> | 2<sup>-4</sup> | 2<sup>-5</sup> | 2<sup>-6</sup> | 2<sup>-7</sup> |                                 |
| ---- | -------------- | -------------- | -------------- | -------------- | -------------- | -------------- | -------------- | ------------------------------- |
| 0    | 1              | 1              | 0              | 0              | 0              | 0              | 0              | +0.75D = 0.5 + 0.25 = 0110 0000 |
| 1    | 1              | 1              | 0              | 0              | 0              | 0              | 0              | -0.75D = 0.5 + 0.25 = 1110 0000 |

#### 反码

若符号位为0，则反码与原码相同

若符号位为1，则数值位全部取反

*反码是原码转换为补码的一个中间态，实际中并没有什么用*

定点整数的表示范围：-(2<sup>n</sup> - 1) ~ 2<sup>n</sup> - 1

定点小数的表示范围：-(1 - 2<sup>-n</sup> ) ~ 1 - 2<sup>-n</sup>

 真值0有 +0 和 -0 两种形式。



#### 补码

若符号位为0，则补码与原码相同

若符号位为1，则补码=反码末位+1（要考虑进位）

定点整数[x]<sub>补</sub> = 1,0000000 表示 x = -2<sup>7</sup> = -128

定点整数的表示范围：-2<sup>n</sup> ~ 2<sup>n</sup> - 1（比原码多表示一个-2<sup>n</sup>）

定点小数[x]<sub>补</sub> = 1,0000000 表示 x = -1

定点小数的表示范围：-1  ~ 1 - 2<sup>-n</sup>

 真值0只有一种形式。



#### 移码

在补码的基础上将符号位取反。

移码只能用于表示整数。

移码表示的整数很方便对比大小。

 真值0只有一种形式。



#### 拓展

由[x]<sub>补</sub>快速求[-x]<sub>补</sub>或由[-x]<sub>补</sub>快速求[x]<sub>补</sub>的方法。

符号位、数值位全部取反，末位+1。

由[-x]<sub>补</sub>快速求[-x]<sub>原</sub>的方法。

1. 符号位保持不变、数值位全部取反，末位+1。
2. 最右边的1及其右边同原码，最右边的1的左边同反码



### 原码补码移码的作用

#### 原码/反码/补码

用硬件电路实现加法是简单的，实现减法是比较困难的，如果硬件既要实现加法功能又要实现减法功能就会导致硬件的设计成本增加，同时复杂度也增加。

用加法运算实现减法运算。

###### 时钟的例子

将时钟从10点调到7点，逆时针调3个，顺时针调9个。

10 -3 = 7

10 + 9 = 19，19 mod 12 = 7

-3 = 9(mod 12)

###### 模运算的性质

-3 = (-1)*12 + 9

9 = 0*12 + 9

21 = 1*12 + 9

33 = 2*12 + 9

-15 = (-2)*12 + 9

...

（mod12）把所有整数分为12类（余数为0～11）

mod12余数相同的数，都是同一类，都是等价的

即10+(-3)、10+9、10+21...在（mod12）的条件下效果相同



｜-3｜+｜9｜ = 12，我们称两个数互为补数。

模 - a的绝对值 = a的补数（是正数）



###### 有符号数的加法

用8bit可表示的范围：0000 0000 ～ 2<sup>8</sup> -1，天然模2<sup>8</sup>

14 + -14 = 0; 

0000 1110 + 1000 1110 = 1001 1100 = -28

期望得到0，实际得到-28

​	0000 1110

\+ 1000 1110

\-------------------

​	 0000 1110

\+ 10000 0000 (2<sup>8</sup>) - 0000 1110

\-------------------

​	0000 1110

\+ 1111 0010

\-------------------

10000 0000（高位1自动被舍弃，得到期望的结果0）



补码的作用：使用补码可将减法操作转变为等价的加法，ALU中无需集成减法器。执行加法操作时，符号位一起参与运算。

#### 移码

真值的递增和移码的绝对值的递增是保持一致的，所以用移码表示的整数很方便对比大小。


### 移位运算

#### 算数移位

985.211

小数点后移1位相当✖️10<sup>1</sup>

小数点前移1位相当➗10<sup>1</sup>

**定义：**

通过改变各个数码位和小数点的相对位置，从而改变各个数码位的位权。可用移位运算实现乘法、除法。

|          | 符号位 | 2<sup>6</sup> | 2<sup>5</sup> | 2<sup>4</sup> | 2<sup>3</sup> | 2<sup>2</sup> | 2<sup>1</sup> | 2<sup>0</sup> | 小数点 |     | 数值 | 右移 | 0～127            |
| -------- | ------ | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------------- | ------ | --- | ---- | ---- | ----------------- |
| 原码     | 1      | 0             | 0             | 1             | 0             | 1             | 0             | 0             | .      |     | -20D |      |                   |
| 算数右移 | 1      | 0             | 0             | 0             | 1             | 0             | 1             | 0             | .      | 0   | -10D | 1位  | -20➗2<sup>1</sup> |
|          | 1      | 0             | 0             | 0             | 0             | 1             | 0             | 1             | .      | 0   | -5D  | 2位  | -20➗2<sup>2</sup> |
|          | 1      | 0             | 0             | 0             | 0             | 0             | 1             | 0             | .      | 1   | -2D  | 3位  | -20➗2<sup>3</sup> |
| 算数左移 | 1      | 0             | 1             | 0             | 1             | 0             | 0             | 0             | .      |     | -40D | 1位  | -20✖️2<sup>1</sup> |
|          | 1      | 1             | 0             | 1             | 0             | 0             | 0             | 0             | .      |     | -80D | 2位  | -20✖️2<sup>2</sup> |
|          | 1      | 0             | 1             | 0             | 0             | 0             | 0             | 0             | .      |     | -32D | 3位  | -20✖️2<sup>3</sup> |

-20 / 8 = 2.5

原码的算数移位：符号位保持不变，仅对数值进行移位。

右移：高位补0，低位舍弃。若舍弃的位等于0，则相当于➗2，若舍弃的位不等于0，则会丢失精度。

左移：低位补0，高位舍弃。若舍弃的位等于0，则相当于✖️2，若舍弃的位不等于0，则会出现严重误差。



#### 反码的算数移位

**正数**

右移：高位补0，低位舍弃。

左移：低位补0，高位舍弃。

**负数**

右移：高位补1，低位舍弃。

左移：低位补1，高位舍弃。



#### 补码的算数移位

**正数**

右移：高位补0，低位舍弃。

左移：低位补0，高位舍弃。

**负数**

右移：高位补1，低位舍弃。同反码。

左移：低位补0，高位舍弃。同补码。



##### 算数移位应用举例

计算机如何处理-20 x 7

7D = 111B = 2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>

=> -20 x (2<sup>0</sup>+2<sup>1</sup>+2<sup>2</sup>)

=> -20 -> 左移0位  + -20 -> 左移1位 + -20 -> 左移2位

*计算机硬件实现乘法是基于算数移位和加法进行的。*



#### 逻辑移位

右移：高位补0，低位舍弃。

左移：低位补0，高位舍弃。

*可以把逻辑移位看作是对“无符号数”的算数移位*。

##### 逻辑移位应用举例

RGB颜色的存储

RGB(102, 139, 139)

R = 102D -> 01100110 

G = 139D -> 10001011 

B = 139D -> 10001011

用3B存储无符号数102，并逻辑左移16位。 

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18  | 19  | 20  | 21  | 22  | 23  | 24  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 0   | 0   | 1   | 1   | 0   |
| 0   | 1   | 1   | 0   | 0   | 1   | 1   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |

用3B存储无符号数139，并逻辑左移8位。 

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18  | 19  | 20  | 21  | 22  | 23  | 24  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 0   | 0   | 0   | 1   | 0   | 1   | 1   |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 0   | 0   | 0   | 1   | 0   | 1   | 1   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |

用3B存储无符号数139。

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18  | 19  | 20  | 21  | 22  | 23  | 24  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 0   | 0   | 0   | 1   | 0   | 1   | 1   |

相加得到3B的RGB值。

| 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18  | 19  | 20  | 21  | 22  | 23  | 24  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | 1   | 1   | 0   | 0   | 1   | 1   | 0   | 1   | 0   | 0   | 0   | 1   | 0   | 1   | 1   | 1   | 0   | 0   | 0   | 1   | 0   | 1   | 1   |



#### 循环移位

右移：高位补移出的低位。

左移：低位补移出的高位。



### 加减运算和溢出判断

#### 原码的加减运算

##### 加法运算

正 + 正 =》绝对值做加法，结果为正

负 + 负 =》绝对值做加法，结果为负

正 + 负 =》绝对值大的减绝对值小的，符号同绝对值大的数

正 + 负 =》绝对值大的减绝对值小的，符号同绝对值大的数



##### 减法运算

“减数”符号取反，转变为加法。

正 - 负 =》正 + 正

负 - 正 =》负 + 负

正 - 正 =》正 + 负

负 + 正 =》负 - 负



#### 补码的加减运算

因为原码的加减运算实现太复杂了，所以计算机使用补码来进行加减运算。

对于补码来说，无论加法还是减法，最后都会转变为加法，由加法器实现运算，符号位也参与运算。

#### 溢出判断

下溢  ｜  负数区   ｜  	0	｜	正数区	｜	上溢	

​				-128							  +127

###### 上溢

只有“正数”+“正数”才会上溢 --- 正 + 正 = 负

###### 下溢

只有“负数”+“负数”才会下溢 --- 负 + 负 = 正



#### 计算机判断溢出的方法

##### 方法一

采用一位符号位。

设A的符号为A<sub>s</sub>，设B的符号为B<sub>s</sub>，运算结果为S<sub>s</sub>，则溢出逻辑表达式为：
$$
V = A_sB_s\overline{S_s} + \overline{A_s}\overline{B_s}S_s
$$
若V=0，表示无溢出，

若V=1，表示有溢出。

A<sub>s</sub>为1且B<sub>s</sub>为1且S<sub>s</sub>为0  =>  正 + 正 = 负。

A<sub>s</sub>为0且B<sub>s</sub>为0且S<sub>s</sub>为1  =>  负 + 负 = 正。



###### 逻辑表达式

与：如ABC，表示A与B与C

仅当A、B、C均为1时，ABC为1，A、B、C中有一个或多个为0，则ABC为0

或：如A+B+C，表示A或B或C

仅当A、B、C均为0时，A+B+C为0，A、B、C中有一个或多个为1，则A+B+C为1

非：如$\overline{\text{A}}$，表示A非

若A为1，则$\overline{A}$为0

若A为0，则$\overline{A}$为1



##### 方法二

采用一位符号位，根据数据位进位情况判断溢出，符号位的进位C<sub>s</sub>，最高数值位的进位C<sub>1</sub>

|      | 符号位的进位C<sub>s</sub> | 最高数值位的进位C<sub>1</sub> |
| ---- | ------------------------- | ----------------------------- |
| 上溢 | 0                         | 1                             |
| 下溢 | 1                         | 0                             |

即C<sub>s</sub>与C<sub>1</sub>不同时有溢出，计算机使用异或运算判断溢出。
$$
V = C_s \oplus C_1
$$


若V=0，表示无溢出，V=1，表示有溢出。



##### 方法三

采用双符号

正数符号位为00，负数符号位为11

正+正，当符号位出现01时，则为上溢，

负+负，当符号位出现10时，则为下溢。

记两个符号位为S<sub>s1</sub>，S<sub>s2</sub>
$$
V = S_{s1} \oplus S_{s2}
$$
若V=0，表示无溢出，V=1，表示有溢出。

*双符号位补码又称：模4补码，*

*单符号位补码又称：模2补码。*

*双符号位补码实际存储时只存储1个符号位，运算时会复制一个符号位*



#### 符号拓展

当发生溢出时，可以将短数据转换成长数据（int -> long）。多出来的位怎么填补？

Eg：8位 -> 16位

##### 正整数（原、反、补码表示都一样）

0,1011010		->		0,00000000 1011010

##### 负整数

原码：1,1011010		->		1,00000000 1011010

反码：1,1011010		->		1,11111111 0100101

补码：1,1011010		->		1,11111111 0100110



##### 正小数（原、反、补码表示都一样）

0.1011010		->		0.1011010 00000000

##### 负小数

原码：1.1011010		&rarr;		1.1011010 00000000

反码：1.1011010		&rarr;		1.0100101 11111111

补码：1.1011010		&rarr;		1.0100110 00000000



### 原码的乘法运算

#### 十进制的乘法

​	0.985

x  0.211	

\-------------

​	  985

​    985

1970

\-------------

0.207835



0.211 = 2x10<sup>-1</sup> + 1x10<sup>-2</sup> + 1x10<sup>-3</sup>

0.985 = 985x10<sup>-3</sup>

0.985 x 0.211 = (985 x 1 x 10<sup>-6</sup>) +  (985 x 1 x 10<sup>-5</sup>) +  (985 x 2 x 10<sup>-4</sup>)



​	0.985

x  0.211	

\-------------

0.000985

0.00985

0.1970

\-------------

0.207835



#### 二进制的乘法

与十进制同理

​	0.1101

x  0.1011	

\-------------

​	   1101

​     1101

  0000

1101

\-------------

0.10001111



乘数：0.1011 = 1x2<sup>-1</sup> + 0x2<sup>-2</sup> + 1x2<sup>-3</sup> + 1x2<sup>-4</sup>

被乘数：0.1101 = 1101x2<sup>-4</sup>

0.1101x 0.1011 = (1101 x 1 x 2<sup>-8</sup>) +  (1101 x 1 x 2<sup>-7</sup>) +  (1101 x 0 x 2<sup>-6</sup>) +  (1101 x 1 x 2<sup>-5</sup>)



​	0.1101

x  0.1011	

\-------------

0.00001101

0.0001101

0.000000

0.01101

\-------------

0.10001111



#### 计算机如何实现

实现方法：先加法再移位，重复n次

符号位单独处理：异或运算
$$
V = X_s \oplus Y_s
$$
数值位取绝对值进行乘法计算

*每次移位是“原码逻辑右移”*



如：设机器字长为 n + 1 = 5位（含一位符号位），[x]<sub>原</sub> = 1.1101，[y]<sub>原</sub> = 0.1011，采用原码一位乘法求x*y。

​		乘积高位					乘数、乘积低位

​			ACC								MQ

<font color="red">0	1	0	0	0</font>	&rarr;		<font color="red">1	1	1	1</font>	0	1	0	1	1

​			&uarr;&darr;

​		  ALU

​			&uarr;

0	1	1	0	1

​			X

​		被乘数

​		



### 补码的乘法运算

补码一位乘法：

进行n轮加法、移位，最后再多来一次加法。

每次加法可能+0、+[x]补、+[-x]补

每次移位是“补码的算数右移”

乘数的符号位参与运算



根据当前MQ中的最低位、辅助位来确定加什么：

- 辅助位 - MQ中最低位 = 1时，(ACC)+[x]补
- 辅助位 - MQ中最低位 = 0时，(ACC)+0
- 辅助位 - MQ中最低位 = -1时，(ACC)+[-x]补



【辅助位】：MQ扩充一位用来表示辅助位，辅助位初始为0，每次右移会使MQ的最低位顶替原本的辅助位，（事实上MQ共n+2位）

 

### 原码的除法运算

x / y = a...b(余数b) &rarr; x = ay + b



设机器字长为 n + 1 = 5位（含一位符号位，n=4），[x]<sub>原</sub> = 0.1011，[y]<sub>原</sub> = 0.1101，求x/y。

​						 0.1101

​			  \--------------------

01101	01011

​			   00000

​			  \--------------------

​				 10110

​				 01101

​			  \--------------------

​					10010

​					01101		

​			  \--------------------

​					   01010

​					   00000

​			  \--------------------

​					     10100

​						 01101	

​			  \--------------------

​							0111



 0.1011 = 0.1101 x 0.1101 + 0.00000111

 

乘数：0.1101 = 1x2<sup>-1</sup> + 1x2<sup>-2</sup> + 0x2<sup>-3</sup> + 1x2<sup>-4</sup>

被乘数：0.1101 = 1101x2<sup>-4</sup>

0.1101x 0.1101 = (1101 x 1 x 2<sup>-8</sup>) +  (1101 x 0 x 2<sup>-7</sup>) +  (1101 x 1 x 2<sup>-6</sup>) +  (1101 x 1 x 2<sup>-5</sup>) + 0.00000111



​						   0.1101

​			  \--------------------

0.1101	0.1011

​			   0.0000

​			  \--------------------

​				0.10110

​				0.01101

​			  \--------------------

​				0.010010

​				0.001101		

​			  \--------------------

​				0.0001010

​				0.0000000

​			  \--------------------

​				0.00010100

​				0.00001101	

​			  \--------------------

​				0.00000111



#### 计算机如何实现

##### 恢复余数法

实现方法：上商0或1，得到余数，余数末尾补0

符号位单独处理：异或运算
$$
V = X_s \oplus Y_s
$$
数值位取绝对值进行除法计算

*每次移位是“原码逻辑左移”*

*计算机很傻，会先默认商1，如果商错了再改商0，并恢复余数。*



如：设机器字长为 n + 1 = 5位（含一位符号位，n=4），[x]<sub>原</sub> = 0.1011，[y]<sub>原</sub> = 0.1101，采用恢复余数法求x/y。

​		被除数、余数					 商

​			ACC								MQ

0	0	1	1	1	&rarr;		<font color="red">0	1	1	0	1</font>	

​			&uarr;&darr;

​		  ALU

​			&uarr;

0	1	1	0	1

​			X

​		除数

余数 = 0.0111 x 2<sup>n</sup>



##### 加减交替法（不恢复余数法）

符号位单独处理：异或运算

数值位取绝对值进行除法计算

若余数为负，则可直接商0，让余数左移1位再加上除数的绝对值，得到下一个新余数。

若余数为正，则商1，让余数左移1位再减去除数的绝对值，得到下一个新余数。



### 补码的除法运算

#### 加减交替法

补码除法：

- 符号位参与运算
- 被除数/余数、除数采用双符号位



规则：

1. 被除数和除数同号，则被除数减去除数，异号则被除数加上除数。
2. 余数和除数同号，商1，余数左移一位减去除数，余数和除数异号，商0，余数左移一位加上除数，重复n次。
3. 末位恒置为1。



### 强制类型转换

定点整数：

- int：4个字节，32bit
- short： 2个字节，16bit

C语言中的定点整数是用“补码”的形式存储的。



#### 无符号与有符号互转

不改变数据内容，改变解释方式

#### 长整数变短整数

高位截断，保留低位。

#### 短整数变长整数

符号扩展



### 数据的存储和排列

大小端模式



### 浮点数的表示

#### 定点数

科学计数法：

302657264526

+11+3.026

阶码+尾数

##### 阶码

阶码正负表示小数点左/右移

阶符+数值，反映数值大小

##### 尾数

数符表示整个数值正负

数符+数值，反映精度



#### 浮点数

阶码： 常用补码或移码表示的定点整数

尾数：常用原码或补码表示的定点小数

浮点数的真值：N = r<sup>E</sup> x M

r：阶码的底，通常为2

E：阶码E反映浮点数的表示范围及小数点的实际位置

M：尾数M的数值部分的位数反映浮点数的精度

尾数给出一个小数，阶码指明了小数点要向前/向后移动几位

例：阶码、尾数均用补码表示，求a、b真值的二进制表示。

a = 0,01;1.1001

阶码0,01对应真值+1；

尾数1.1001对应的真值-0.0111 = -(2<sup>-2</sup>+2<sup>-3</sup>+2<sup>-4</sup>)

a的真值 = 2<sup>1</sup> x (-0.0111) = -0.111

b=0,10;0.01001

阶码0,10对应真值+2；

尾数0.01001对应的真值+0.01001 = +(2<sup>-2</sup>+2<sup>-5</sup>)

b的真值 = 2<sup>2</sup> x (+0.01001) = +1.001



#### 尾数规格化

如果尾数的最高位是无效值，会丧失精度

尾数去掉无效的最高位，例如：

2<sup>2</sup> x (+0.01001) => 2<sup>1</sup> x (+0.1001) 

规则：

尾数算数左移1位，阶码减1。直到尾数最高位是有效值（左归）



#### 浮点数尾数的规格化

规格化浮点数：规定尾数的最高位数值位必须是一个有效值。

左归：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减1。

右归：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移一位，阶码加1。

例：a = 010; 00.1100, b = 010; 00.1000，求 a + b

a = 2<sup>2</sup> x 00.1100, b = 2<sup>2</sup> x 00.1000

a + b = 2<sup>2</sup> x (00.1100 +  00.1000)

​		  =  2<sup>2</sup> x 01.0100 

​		 =  2<sup>3</sup> x 00.1010



*采用“双符号位”，当溢出发生时，可以挽救。更高的符号位是正确的符号位*



### IEEE745标准

#### 移码

定义：移码 = 真值 + 偏置值

此处8位移码的偏置值=128D=1000 0000B，即2<sup>n-1</sup>

-127的移码：

真值-127 = -1111 111B

移码=-1111 111 + 1000 0000 = 0000 0001

#### IEEE745标准

规定：偏置值 = 127D = 0111 1111B，即2<sup>n-1</sup> -1

表示范围：-128～127，实际会取-126～127

特殊值：0000 0000（-127） 和 1111 11111（-128），这两个状态有特殊用途。

构成

| 数符部分      | 阶码部分（移码表示） | 尾数部分（原码表示，隐藏表示最高位1，表示成1.M） |
| ------------- | -------------------- | ------------------------------------------------ |
| m<sub>s</sub> | E                    | M                                                |



| 类型                   | 数符 | 阶码 | 尾数数值 | 总位数 | 偏置值（H） | 偏置值（D） |
| ---------------------- | ---- | ---- | -------- | ------ | ----------- | ----------- |
| 短浮点数float，单精度  | 1    | 8    | 23       | 32     | 7FH         | 127         |
| 长浮点数double，双精度 | 1    | 11   | 52       | 64     | 3FFH        | 1023        |
| 临时浮点数long double  | 1    | 15   | 64       | 80     | 3FFFH       | 16383       |

规格化的短浮点数的真值为：(-1)<sup>s</sup> x 1.M x 2<sup>E-127</sup>

规格化的长浮点数的真值为：(-1)<sup>s</sup> x 1.M x 2<sup>E-1023</sup>



例子：

将十进制数-0.75转换为IEEE754的单精度浮点数格式表示。

尾数规格化：(-0.75)<sub>10</sub> = (-0.11)<sub>2</sub> = (-1.1)<sub>2</sub> x 2<sup>-1</sup>

数符 = 1

尾数部分 = .10000000...（隐含最高位1）

阶码真值 = -1

单精度浮点数偏移量 = 127D

移码 = 阶码真值 + 偏移量 = -1 + 111 1111 = 0111 1110（凑足8位）

*也可以这么算，移码 = 阶码真值 + 偏移量 = -1 + 127 = 126 = 0111 1110（凑足8位）*

最后得：1 0111 1110 1000 0000 0000 0000 0000 000



###### IEEE 754单精度浮点型能表示的最小绝对值、最大绝对值是多少？

最小绝对值：尾数全为0，阶码真值最小-126，对应移码机器数0000 0001，此时整体的真值为 (1.0)<sub>2</sub> x 2<sup>-126</sup>

最大绝对值：尾数全为1，阶码真值最大127，对应移码机器数1111 1110，此时整体的真值为 (1.1111....11)<sub>2</sub> x 2<sup>127</sup>

| 格式   | 规格化最小绝对值                                        | 规格化最大绝对值                                                                                |
| ------ | ------------------------------------------------------- | ----------------------------------------------------------------------------------------------- |
| 单精度 | E=1，M=0： 1.0 x 2<sup>1-127</sup> = 2<sup>-126</sup>   | E=254，M=.11...1：1.11...1 x 2<sup>254-127</sup> = 2<sup>127</sup> x (2 - 2 <sup>-23</sup>)     |
| 双精度 | E=1，M=0： 1.0 x 2<sup>1-1023</sup> = 2<sup>-1022</sup> | E=2046，M=.11...1：1.11...1 x 2<sup>2046-1023</sup> = 2<sup>1023</sup> x (2 - 2 <sup>-52</sup>) |



总结：

由浮点数确定真值（阶码不是全0、也不是全1）

1. 根据“某浮点数”确定数符、阶码、尾数分布
2. 确定尾数1.M（注意补充最高的隐含位1）
3. 确定阶码的真值 = 移码 - 偏置值（可将移码看作无符号数，用无符号数的值减去偏置值）
4. (-1)<sup>s</sup> x 1.M x 2<sup>E-偏置值</sup>



### 浮点数的运算

#### 浮点数加减运算步骤

1. 对阶
2. 尾数加减
3. 规格化
4. 舍入
5. 判溢出

如：9.85211 x 10<sup>12</sup> + 9.96007 x 10<sup>10</sup>

=>  9.85211 x 10<sup>12</sup> + 0.096007 x 10<sup>12</sup>

=> 9.9517107 x 10<sup>12</sup>

=> 如果尾数加减后出现类似 0.0099517107 x 10<sup>12</sup>，需要“左规”，如果尾数加减出现类似 99.517107  x 10<sup>12</sup>时，需要“右规”。

=> 若规定只能保留6位有效尾数，则 9.9517107 x 10<sup>12</sup>  &rarr;  9.951710 x 10<sup>12</sup>，多余的砍掉或者四舍五入。

=> 若规定阶码不能超过两位，则运算后阶码超出范围，则溢出，如：9.85211 x 10<sup>99</sup> + 9.96007 x 10<sup>99</sup> = 19.81218 x 10<sup>99</sup>，规格化并用四舍五入保留六位小数，得：1.981218 x 10<sup>100</sup>，阶码100超过两位，发生溢出（注：尾数发生溢出未必导致整体溢出，也许可以通过第二步、第三步来拯救）。

​	

#### 舍入规则

0舍1入法：类似十进制数运算中的“四舍五入”法，即在尾数右移时，被移去的最高数值为0，则舍去；被移去的最高数值为1，则在尾数的末位加1.这样可能会使尾数又溢出，此时需要再做一次右规。



恒置1法：尾数右移时，不论丢掉的最高数值位是1还是0，都使右移后的尾数末位恒置1。这种方法同样有使尾数变大和变小的两种可能。



#### 强制类型转换

| 类型      | 16位机器 | 32位机器 | 64位机器 |
| --------- | -------- | -------- | -------- |
| char      | 8        | 8        | 8        |
| short     | 16       | 16       | 16       |
| int       | 16       | 32       | 32       |
| long      | 32       | 32       | 64       |
| long long | 64       | 64       | 64       |
| float     | 16       | 32       | 32       |
| double    | 64       | 64       | 64       |

##### 无损转换

char &rarr; int &rarr; long &rarr; double

float &rarr;  double

范围、精度从小到大，转换过程没有损失

##### 有损转换

int &rarr; float 可能损失精度

float &rarr; int 可能溢出及损失精度



### 电路的基本原理、加法器设计

ALU的作用：

- 算数运算：加、减、乘、除等
- 逻辑运算：与、或、非、异或等
- 辅助功能：移位、求补等


## 第三章
### 主存简单模型和寻址概念

#### 主存储器

存储体

MAR

MDR



地址线：

数据线：



K：2<sup>10</sup>

M：2<sup>20</sup>

G：2<sup>30</sup>

T：2<sup>40</sup>



常见的描述：

8K x 8位的存储芯片，即2<sup>13</sup> x 8bit，有13根地址线，8根数据线。



#### 寻址

按照不同大小的单元来切分整个存储器，总共可以切成多少份。



假设总容量位1KB

按字节寻址：1K个存储单元，每个单元1B

按字寻址：256个存储单元，每个单元4B

按半字寻址：512个存储单元，每个单元2B

按双字寻址：128个存储单元，每个单元8B



### 半导体存储器RAM

#### 半导体存储芯片的基本结构

##### 存储矩阵

由大量相同的位存储单元阵列构成。

##### 译码驱动

将来自地址总线的地址信号翻译成对应存储单元的选通信号，该信号在读写电路的配合下完成对被选中单元的读/写操作。

##### 读写电路

包括读出放大器和写入电路，用来完成读/写操作。



##### 读/写控制线

决定芯片进行读/写操作。读写共用一根线，或者分开两根线。

##### 片选线

确定哪个存储芯片被选中。可用于容量扩充。

##### 地址线

是单向输入的，其位数与存储字的个数有关。

###### 数据线

是双向的，其位数与读写或写入的数据位数有关。



#### 半导体随机存取器

| 类型         | SRAM（Static Random Access Memory）静态随机存储器 | DRAM（Dynamic Random Access Memory）动态随机存储器 | 备注                                                      |
| ------------ | ------------------------------------------------- | -------------------------------------------------- | --------------------------------------------------------- |
| 存储信息0，1 | 触发器，双稳态                                    | 电容，充放电                                       | DRAM都以电信号的形式存储0/1，断电就丢失信息：易失性存储器 |
| 破坏性读出   | 非，读：查看触发器状态，写：改变触发器状态        | 是，读：连接电容，检测电流变化，写：给电容充/放电  | DRAM读出后需要重新充电                                    |
| 需要刷新     | 不要，能保持两种稳定的状态                        | 需要，电容上的电荷只能维持2ms                      |                                                           |
| 送行列地址   | 同时送                                            | 分两次送                                           | DRAM地址线可以复用，线数减少一半                          |
| 运行速度     | 快                                                | 慢                                                 |                                                           |
| 集成度       | 低，6个逻辑元件构成                               | 高，1个或3个逻辑元件构成                           |                                                           |
| 发热量       | 大                                                | 小                                                 |                                                           |
| 存储成本     | 高                                                | 低                                                 |                                                           |
| 应用         | 常用作Cache                                       | 常用作主存                                         |                                                           |



#### DRAM的刷新

##### 多久刷新一次？

一般为2ms

##### 每次刷新多少存储单元

以行为单位，每次刷新一行存储单元。

使用行列地址，可以减少选通线的数量

##### 如何刷新

有硬件支持，读出一行的信息后重新写入，占用1个读/写周期

##### 在什么时候刷新

假设DRAM内部结构排列成128x128的形式，读/写周期（存取周期）0.5us。

方案一：分散刷新

每次读写完都刷新一行，系统的存取周期变为1us，前0.5us时间用于正常读写，后0.5us时间用于刷新某行

方案二：集中刷新

2ms内集中安排时间全部刷新，系统的存取周期还是0.5us，由于有一段时间专门用于刷新，造成无法访问存储器，称为访存“死区”。

方案三：异步刷新

2ms内每行刷新1次即可，2ms内需要产生128次刷新请求，每隔2ms/128=15.6us一次，每15.6us内有0.5us的“死时间”。



#### RAM的存储周期

启动存取						存取完					下次存取

​					存取时间					恢复时间

​									存取周期



### 半导体存储器ROM

#### RAM易失性存储器

主存储器RAM：存储指令和数据

CPU：自动到主存中取指令；按指令的指示进行下一步工作。

ROM：保存固定的信息



#### ROM（Read Only Memory）非易失性存储器

#### 发展历程

掩膜式只读存储器（MROM）：

​	存储内容由半导体制造厂按用户提出的要求在芯片的生产过程中直接写入，无法修改。

一次可编程只读存储器（PROM）

​	存储内容由用户用专门的设备（编程器）一次性写入，之后无法修改。

可擦除可编程只读存储器（EPROM）

​	紫外线擦除，电擦除，修改次数有限，写入时间很长。

闪速存储器（Flash Memory）

​	如U盘，写入速度较快。

固态硬盘（Solid State Drives）

​	控制单元+FLASH芯片。



### 存储器基本概念

#### 按存储介质分类

磁芯存储器

磁表面存储器，磁盘，磁带

半导体存储器

光存储器



#### 存储器的层次化结构

CPU	&hArr; 	Cache	&hArr;	主存	&hArr;	辅存

高速缓存为了解决CPU和主存速度不匹配的问题

辅存为了解决存储容量不够大的问题



### 主存与CPU的连接

译码器



#### 主容量拓展

### 位拓展

### 字拓展

线选法

译码片选法



### 双口RAM和多模块存储器

#### 双端口RAM

了解即可

#### 多模块存储器

##### 单体多字存储器

多个普通存储器构成，每个存储单元存储m个字，总线宽度也为m个字，一次并行读出m个字

指令和数据在主存内必须是连续存放的。



##### 多体并行存储器

每个模块都有相同的容量和存取速度。

各个模块都有独立的读写控制电路、地址寄存器和数据寄存器。

它们既能并行工作，又能交叉工作。



###### 高位交叉编址模式

每个存储体存储周期为T

竖向编址

连续取n个存储字，耗时nT

###### 低位交叉编址模式

横向编址

连续取n个存储字，耗时T+(n-1) $\tau$



如：

模块数m=4，存储周期为T，字长为W，数据总线宽度为W，总线传输周期为r，连续存取n个字，求交叉存储器的带宽。

分析：

有m个存储体，存储周期为T，字长为W，每隔r时间启动下一个存储体，连续存取n个字，求存储器的存储速率。

连续存取n个字耗时 = T+(n-1)r，m > T/r
$$
带宽 = \frac {nW} {T+(n-1)r}
$$
当n足够大时，带宽 = W / r





### 高速缓冲存储器

命中率：CPU欲访问的信息已在Cache中的比率。

设一个程序执行期间，Cache的总命中次数为N<sub>c</sub>，访问主存的总次数为N<sub>m</sub>，则命中率：
$$
H = \frac {N_c} {N_c + N_m}
$$
缺失率：M = 1 - H



例子：

假设Cache的速度时主存的5倍，且Cache的命中率为95%，则采用Cache后，存储器性能提高多少（设Cache和主主存同时被访问，若Cache命中则中断访问主存）？

解：

设Cache的存取周期为t，则主存的存取周期为5t

Cache和主存同时访问，不命中时访问时间为5t

故系统的平均访问时间为T<sub>a</sub> = 0.95 x t + 0.05 x 5t = 1.2t

设每个周期可存取的数据量为S，

则存储系统的带宽为S/1.2t，

不采用Cache时的带宽为S/5t，

故性能为原来的 (S/1.2t) / (S/5t) = 5t / 1.2t = 4.17倍，即提高了3.17倍。

系统效率 e = t / 1.2t = 83.3%



### Cache-地址映射

#### 全相联映射

空位随意放

主存字块标记 + 字块内地址

#### 直接映射

对号入座

主存字块标记 + Cache字块地址 + 字块内地址

#### 组相联映射

按号分组

主存字块标记 + 组地址 + 字块内地址



### Cache替换算法及写策略

#### 替换算法

##### 随机算法（RAND）

随机的确定替换的Cache。它的实现比较简单，但没有依据程序访问的局部性原理，故可能命中率较低。

##### 先进先出算法（FIFO，First In First Out）

选择最早调入的进行替换，它比较容易实现，但也没有依据程序访问的局部性原理，可能会把一些需要经常使用的程序块（如循环程序）也作为最早进入Cache的块替换掉。

##### 近期最少使用算法（LRU，Least Recently Used）

依据程序访问的局部性原理选择近期内长久未访问的存储行作为替换的行，平均命中率要比FIFO要高，是堆栈类算法。LRU算法对每行设置一个计数器，Cache每命中一次，命中行计数器清0，而其他各行计数器均加1，需要替换时比较各特定行的技术值，将技术值最大的行换出。

##### 最不经常使用算法（LFU）

将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，将计数值最小的行换出。



#### 写策略

##### 写回法搭配写分配法



##### 全写法搭配非写分配法



##### 多级Cache



### 虚拟存储器

虚拟存储器是一个逻辑模型

功能：用户给出一个地址，叫做虚地址或逻辑地址，虚拟存储器要给出该地址对应的数据。

实现：由辅助硬件将虚地址映射到主存当中的某个单元，主存单元地址称为实地址或物理地址。



#### 页式虚拟存储器

虚拟空间与主存空间都被划分成同样大小的页，主存的页称为实页，虚存的页称为虚页。

虚地址结构：虚页号+页内地址

实地址结构：实页号+页内地址



虚页号到实页的映射号通过一张页表实现。



##### 页表基址寄存器

负责存储页表起始地址。

页表起始地址和虚页号进行拼接得到页表项地址。

页表项地址指向虚页号对应的实页号所在位置。



#### 段式虚拟存储器

段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。

虚拟地址分为两部分：段号和段内地址。

段表：每一行记录了与某个段对应的段号、装入位、段起点和段长等信息。

由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。

虚地址结构：段号+段内地址

实地址结构：主存地址



##### 段表基址寄存器

负责存储段表起始地址。

段表起始地址和段号进行拼接得到页表项地址。

段表项地址与段内地址相加得到虚地址对应的主存地址。


## 第四章
### 指令系统

#### 指令的定义

指令（又称机器指令），是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。

一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。



注：

一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。



#### 指令的格式

一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。

一条指令通常要包括操作码字段和地址码字段两部分：

一条指令的结构：

操作码（OP）+ 地址码（A）



##### 操作码的功能

用户要干什么？

停机中断

求反求补

加减乘除

...



##### 地址码的功能

对谁进行操作？

不需要操作对象

需要一个操作对象

...



例子：设指令字长及存储字长均为32位，操作码占8位。

#### 四地址指令

| OP  | A<sub>1</sub> | A<sub>2</sub> | A<sub>3</sub>(结果) | A<sub>4</sub>（下址） |
| --- | ------------- | ------------- | ------------------- | --------------------- |

指令含义：

（A<sub>1</sub>）OP（A<sub>2</sub>）&rarr;	A<sub>3</sub>，A<sub>4</sub> = 下一条将要执行指令的地址。

4个地址码字段各占6位，指令操作数直接寻址范围为2<sup>6</sup> = 64；完成一条指令需要访存4次。



####  三地址指令

| OP  | A<sub>1</sub> | A<sub>2</sub> | A<sub>3</sub>(结果) |
| --- | ------------- | ------------- | ------------------- |

引入程序计数器PC，执行一条指令后自动执行下一条指令。

指令含义：

（A<sub>1</sub>）OP（A<sub>2</sub>）&rarr;	A<sub>3</sub>

3个地址码字段各占8位，指令操作数直接寻址范围为2<sup>8</sup> = 256；完成一条指令需要访存4次。



####  二地址指令

| OP  | A<sub>1</sub>（目的操作数） | A<sub>2</sub>（源操作数） |
| --- | --------------------------- | ------------------------- |

指令含义：

（A<sub>1</sub>）OP（A<sub>2</sub>）&rarr;	A<sub>1</sub>

2个地址码字段各占12位，指令操作数直接寻址范围为2<sup>12</sup> = 4K；完成一条指令需要访存4次。



####  一地址指令

| OP  | A<sub>1</sub> |
| --- | ------------- |

指令含义：

1. OP（A<sub>1</sub>）&rarr;	A<sub>1</sub>，如加1、减1、取反、求补等，完成一条指令需要访存3次。
2. （ACC）OP（A<sub>1</sub>）&rarr;  ACC，隐含约定目的地址为ACC，完成一条指令需要访存2次。

1个地址码字段各占24位，指令操作数直接寻址范围为2<sup>24</sup> = 16M。



####  零地址指令

| OP  |
| --- |

指令含义：

1. 不需要操作数，如空操作、停机、关中断等指令。
2. 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶。



#### 指令分类

##### 按整条指令的长度分类

定长指令字结构：指令长度固定。

变长指令字结构：指令长度不等。



##### 按操作码的长度分类

定长操作码：n位 &rarr; 2<sup>n</sup>条指令。

扩展操作码：操作码长度可变。



#### 扩展操作码

基本结构：

| OP  | A<sub>1</sub> | A<sub>2</sub> | A3  |
| --- | ------------- | ------------- | --- |



设指令字长为16位：

前4位为基本操作码字段OP，另有3个4位长的地址字段A<sub>1</sub>、A<sub>2</sub>和A<sub>3</sub>。



4位基本操作码若全部用于三地址指令，则有16条。

但至少须将1111留作扩展操作码之用，即三地址指令为15条；

1111 1111留作扩展操作码之用，二地址指令为15条；

1111 1111 1111 留作扩展操作码之用，一地址指令为15条；

零地址指令为16条。



#### 操作类型

#### 数据传送

LOAD作用：把存储器中的数据放到寄存器中。

STORE作用：把寄存器中的数据放到存储器中。



#### 算术逻辑操作

算术：加、减、乘、除、增1、减1、求补、浮点运算、十进制运算

逻辑：与、或、非、异或、位操组、位测试、位清除、位求反



#### 移位操作

算术移位、逻辑移位、循环移位（带进位和不带进位）



#### 转移操作

无条件转移：JMP

条件转移：JZ，结果为0，JO：结果溢出，JC：结果有进位

调用和返回CALL和RETURN

陷阱（Trap）与陷阱指令



#### 输入输出操作

CPU寄存器与IO端口之间的数据传送（端口即IO接口中的寄存器）


### 指令寻址

#### 数据存放

##### 按字节编址

每个字节存储单元都有一个地址编号，一个格子为一个字节

| 0   | 1   | 2   | 3   |
| --- | --- | --- | --- |
| 4   | 5   | 6   | 7   |
| 8   | 9   | 10  | 11  |
| 12  | 13  | 14  | 15  |
| 16  | 17  | 18  | 19  |
| 20  | 21  | 22  | 23  |
| 24  | 25  | 26  | 27  |



###### 按字节地址寻址

以一个格子为一个存储单元，称为字节存储单元。

按字节地址寻址：给出一个字节地址，可以取出长度为一个字节的数据。

假设某数据长度为4B，则需要给出4个字节地址。



###### 按字地址寻址

以4个格子为一个存储单元，称为字存储单元。

按字地址寻址：给出一个字地址，可以取出长度为一个字的数据。

字地址：

0～3为一个字，4～7为一个字...，每个字中最小的字节地址为字地址。

假设某数据长度为4B，则需要给出1个字地址。



##### 按字编址

4个字节为一个存储单元来编号



#### 数据存放方式

大端方式：数据的高位存放在存储单元的低地址部分。

小端方式：数据的低位存放在存储单元的低地址部分。



#### 三个字长

机器字长：CPU一次能处理的二进制数据的位数。

指令字长：一个指令字中包含二进制代码的位数。

	- 单字长指令：指令长度 = 机器字长
	- 半字长指令：指令长度 = 机器字长/2
	- 双字长指令：指令长度 = 机器字长*2

存储字长：一个存储单元存储二进制代码的长度。



#### 边界对齐存储

起始地址是字长（按字节算）的整数倍。



#### 指令寻址

下一条欲执行指令的指令地址，始终由程序计数器PC给出。



##### 顺序寻址

（PC）+1  &rarr;  PC



##### 跳跃寻址

由转移指令指出



举例：

| 指令地址 | 操作码 | 地址码 | PC（默认指向第一条地址0）    |
| -------- | ------ | ------ | ---------------------------- |
| 0        | LDA    | 1000   | 执行完后自动+1，变为1        |
| 1        | ADD    | 1001   | 2                            |
| 2        | DEC    | 1200   | 3                            |
| 3        | JMP    | 7      | 将PC指向7，跳到第7条指令执行 |
| 4        | LDA    | 2000   |                              |
| 5        | SUB    | 2001   |                              |
| 6        | INC    |        |                              |
| 7        | LDA    | 1100   |                              |
|          | ...    |        |                              |



### 数据寻址

确定本条指令的操组数地址



#### 操作数类型

地址：无符号数

数字：定点数、浮点数、十进制数

字符：ASCII码

逻辑数：逻辑运算



#### 寻址方式

| 0000 隐含寻址   | 0001 立即寻址       | 0010 直接寻址 | 0011 间接寻址 |
| --------------- | ------------------- | ------------- | ------------- |
| 0100 寄存器寻址 | 0101 寄存器间接寻址 | 0110 相对寻址 | 0111 基础寻址 |
| 1000 变址寻址   | 1001 堆栈寻址       |               |               |



#### 组成

##### 一地址指令

| 操作码（OP） | 寻址特征 | 形式地址（A） |
| ------------ | -------- | ------------- |

操作数的真实地址称为EA。



假设指令字长 = 机器字长 = 存储字长，假设操作数为3



#### 立即寻址

形式地址A就是操作数本身，又称为立即数，一般采用补码形式。#号表示立即寻址特征。

优点：指令执行阶段不访问主存，指令执行时间最短。

缺点：A的位数限制了立即数的范围，如A的位数为n，且立即数采用补码时，可表示的数据范围为-2<sup>n-1</sup> ~ 2<sup>n-1</sup> - 1。



##### 访存次数

取指令，访存1次

执行指令，访存0次

不考虑存结果，共访存1次。



#### 直接寻址

指令中的形式地址A就是操组数的真实地址EA，即EA=A。



优点：简单，指令执行阶段仅访问一次主存，不需要专门计算操作数地址。

缺点：

- A的位数决定了该指令操作数的寻址范围；操作数的地址不易修改。



##### 访存次数

取指令，访存1次

执行指令，访存1次

不考虑存结果，共访存2次。



#### 间接寻址

指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数的有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=(A)。



又可分为一次间址和两次间址



优点：

- 可扩大寻址范围（有效地址EA的位数大于形式地址A的位数）。
- 便于编制程序（用间接寻址可以方便的完成子程序返回）。

缺点：指令在执行阶段要多次访存（一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存）。



##### 访存次数

一次间址

取指令，访存1次

执行指令，访存2次

不考虑存结果，共访存3次。



#### 寄存器寻址

在指令字中直接给出操组数所在的寄存器编号，即EA=R<sub>i</sub>，其操作数在由R<sub>i</sub>所指的寄存器内。



优点：

- 指令在执行阶段不访问主存，只访问寄存器。
- 指令字短且执行速度快，支持向量/矩阵运算。

缺点：寄存器价格昂贵，计算机中寄存器个数有限。



##### 访存次数

取指令，访存1次

执行指令，访存0次

不考虑存结果，共访存1次。



#### 寄存器间接寻址

寄存器R<sub>i</sub>中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA=(R<sub>i</sub>)。



特点：与一般间接寻址相比速度更快，但指令的执行阶段需要访问主存（因为操作数在主存中）。



##### 访存次数

取指令，访存1次

执行指令，访存1次

不考虑存结果，共访存2次。



#### 隐含寻址

不是明显的给出操作数地址，而是在指令中隐含着操组数的地址。



优点：有利于缩短指令字长。

缺点：需增加存储操组数或隐含地址的硬件。

​                     

### 数据寻址-偏移寻址

#### 基址寻址

将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(BR)+A。

- 采用专用寄存器BR作为基址寄存器
- 采用通用寄存器作为基址寄存器

基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定。在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由操作系统决定。

优点：可扩大寻址范围（基址寄存器的位数大于形式地址A的位数）；用户不必考虑自己的程序存于主存的哪一个空间区域，故有利于多道程序设计，以及可用于编制浮动程序。



#### 变址寻址

有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，即EA=(IX)+A，其中IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器。

变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基础）。

优点：可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）；在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。

变址寻址与基址寻址配合使用：EA=A+(BR)+(IX)

变址寻址与间接寻址配合使用：

EA=(A+(IX))，先变址后间址；

EA=(A)+(IX)，先间址后变址。



#### 相对寻址

把程序计数器PC的内容加上指令格式中的形式地址A而形成操组数的有效地址，即EA=(PC)+A，其中A是相对于当前指令地址的位移量，可正可负，补码表示。

优点：操组数的地址不是固定的，它随着PC值的变化而变化，并且指令地址之间总是相差一个固定值，因此便于程序浮动。

相对寻址广泛应用于转移指令。



### 数据寻址-堆栈寻址

操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操组数地址。

堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出（LIFO）”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆栈指针（SP）。





### CISC和RISC替换版

#### CISC（Complex Instruction Set Computer）

设计思路：一条指令完成一个复杂的基本功能。

代表：x86架构，主要用于笔记本、台式机等。



80-20规律：典型程序中80%的语句仅仅使用处理机中20%的指令，所以诞生RISC



#### RISC（Reduced Instruction Set Computer）

设计思路：一条指令完成一个基本“动作”，多条指令组合完成一个复杂的基本功能。

代表：ARM架构，主要用于手机、平板等。

| 类别             | CISC                                 | RISC                                 |
| ---------------- | ------------------------------------ | ------------------------------------ |
| 指令系统高       | 复杂，庞大                           | 简单，精简                           |
| 指令数目         | 一般大于200条                        | 一般小于100条                        |
| 指令字长         | 不固定                               | 定长                                 |
| 可访存指令       | 不加限制                             | 只有LOAD/STORE指令                   |
| 各种指令执行时间 | 相差较大                             | 绝大多数在一个周期内完成             |
| 各种指令使用频度 | 相差很大                             | 都比较常用                           |
| 通用寄存器数量   | 较少                                 | 多                                   |
| 目标代码         | 难以用优化编译生成高效的目标代码程序 | 采用优化的编译程序，生成代码较为高效 |
| 控制方式         | 绝大多数为微程序控制                 | 绝大多数为组合逻辑控制               |
| 指令流水线       | 可以通过一定方式实现                 | 必须实现                             |


## 第五章
中央处理器

### CPU的功能和结构

#### CPU的功能

1. 指令控制：完成取指令、分析指令和执行指令的操作，即程序的顺序控制。
2. 操作控制：一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。
3. 时间控制：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。
4. 数据加工：对数据进行算术和逻辑运算。
5. 中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理。



#### 运算器

对数据进行加工

#### 控制器

协调并控制计算机各部件执行程序的指令序列，基本功能包括取指令、分析指令、执行指令。



取指令：自动形成指令地址；自动发出取指令的命令。

分析指令：操作码译码（分析本条指令要完成什么操作）；产生操作数的有效地址。

执行指令：根据分析指令得到的“操作命令”和“操作数地址”，形成操作信号控制序列，控制运算器、存储器以及IO设备完成相应的操作。

中断处理：管理总线及输入输出；处理异常情况（如掉电）和特殊请求（如打印机请求打印一行字符）。



#### 运算器的基本结构

算术逻辑单元：主要功能是进行算术和逻辑运算。

通用寄存器：用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。

暂存寄存器：用于暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容。

累加寄存器：它是一个通用寄存器，用于暂时存放ALU运算的结果信息，用于实现加法运算。

程序状态字寄存器：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志（OP）、符号标志（SF）、零标志（ZF）、进位标志（CF）等。PSW中的这些位参与并决定微操作的形成。

移位器：对运算结果进行移位运算。

计数器：控制乘除运算的操作步数。



#### 专用数据通路方式

根据指令执行过程中的数据和地址的流动方向安排连接线路。

优点：

性能较高，基本不存在数据冲突现象，但结构复杂，硬件量大，不易实现。



方案一：

使用多路选择器根据控制信号选择一路输出。



方案二：

使用三态门可以控制每一路是否输出。



#### CPU内部单总线方式

将所有寄存器的输入端和输出端都连接到一条公共的通路上。

优点：

结构简单，容易实现，但数据传输存在较多冲突的现象，性能较低。



#### 运算器的基本结构

程序计数器：用于指出下一条指令在主存中存放地址。CPU就是根据PC的内容去主存中取指令的。因程序中指令（通常）是顺序执行的，所以PC有自增功能。

指令寄存器：用于保存当前正在执行的那条指令。

指令译码器：仅对操作码字段进行译码，向控制器提供特定的操作信号。

微操作信号发生器：根据IR的内容（指令）、PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。

时序系统：用于产生各种时序信号，它们都是由统一时钟（CLOCK）分频得到。

存储地址寄存器：用于存放所要访问的主存单元的地址。

存储器数据寄存器：用于存放向主存写入的信息或从主存中读出的信息。



#### CPU基本结构

ALU

寄存器

中断系统

CU



### 指令周期的数据流
#### 指令执行过程

指令周期：CPU从主存中每取出并执行一条指令所需的全部时间。

指令周期常常用若干机器周期来表示，机器周期又叫CPU周期。

一个机器周期又包含若干始终周期（也称为节拍、T周期或CPU时钟周期，它是CPU操作的最基本单位）。

每个指令周期内的机器周期数可以不等，每个机器周期内的节拍数也可以不等。



#### 指令周期流程

取指周期：取指令

间址周期：取有效地址

执行周期：取操作数

中断周期：保护程序断点

四个周期都有CPU访存操作，只是访问的目的不同。

CLK触发器，判断处在哪一个周期。



##### 取指周期的数据流

1. 当前指令地址送至存储器地址寄存器，记做：(PC)	&rarr;	MAR
2. CU发出控制信号，记控制总线传到主存，这里是读信号，记做：1&rarr;R
3. 将MAR所指主存中的内容经数据总线送入MDR，记做：M(MAR)&rarr;MDR
4. 将MDR中的内容（此时是指令）送入IR，记做：(MDR)&rarr;IR
5. CU发出控制信号，形成下一条指令地址，记做：(PC)+1&rarr;PC



##### 间址周期的数据流

1. 将指令的地址码送入MAR，记做：Ad(IR)&rarr;MAR 或 Ad(MDR)&rarr;MAR
2. CU发出控制信号，启动主存做读操作，记做：1&rarr;R
3. 将MAR所指主存中的内容经数据总线送入MDR，记做：M(MAR)&rarr;MDR
4. 将有效地址送至指令的地址码字段，记做：MDR&rarr;Ad(IR)



##### 执行周期的数据流

执行周期的任务是根据IR中的指令字的操作码和操作数通过ALU操作产生执行结果。不同指令的执行周期操作不同，因此没有统一的数据流向。



##### 中断周期的数据流

中断：暂停当前任务去完成其他任务。为了能够恢复当前任务，需要保存断点。一般使用堆栈来保存断点，这里用SP表示栈顶地址，假设SP指向栈顶元素，进栈操作是先修改指针，后存入数据。

1. CU控制将SP减1，修改后的地址送入MAR，记做：(SP)-1 &rarr; SP，(SP)&rarr;MAR，本质上是将断点存入某个存储单元，假设其地址为a，故可记做：a&rarr;MAR
2. CU发出控制信号，启动主存做写操作，记做：1 &rarr; W
3. 将断点(PC内容)送入MDR，记做：(PC) &rarr; MDR
4. CU控制将中断服务程序的入口地址（由向量地址形成部件产生）送入PC，记做：向量地址&rarr;PC



###### 指令执行方案

一个指令周期通常要包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。

方案一：单指令周期

对所有指令都选用相同的执行时间来完成。

指令之间串行执行；指令周期取决于执行时间最长的指令的执行时间。

对于那些本来可以在更短时间内完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。



方案二：多指令周期

对不同类型的指令选用不同的执行步骤来完成。

指令之间串行执行；可选用不同个数的时钟周期来完成不同指令的执行过程。

需要更复杂的硬件设计。



方案三：流水线方案

在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。

指令之间并行执行。



### 数据通路-CPU内部单总线方式

数据通路：数据在功能部件之间传送的路径。

信息从哪里开始中间经过哪些部件最后传到哪里。

由控制部件产生的控制信号建立数据通路。

数据通路的基本结构：

- CPU内部单总线方式
- CPU内部多总线方式
- 专用数据通路方式



#### CPU内部单总线方式

内部总线：

是指同一部件，如CPU内部连接各寄存器及运算部件之间的总线。

系统总线：

是指同一台计算机系统的各部件，如CPU、内存、通道和各类I/O接口间互相连接的总线。



#### 寄存器之间的数据传送

比如把PC内容送至MAR，实现传送操作的流程及控制信号为：

(PC) &rarr; Bus，PC<sub>out</sub>有效，PC内容送总线

Bus &rarr; MAR，MAR<sub>in</sub>有效，总线内容送MAR



#### 主存与CPU之间的数据传送

比如CPU从主存读取指令，实现传送操作的流程及控制信号为：

(PC) &rarr; Bus &rarr; MAR，PC<sub>out</sub>和MAR<sub>in</sub>有效，现行指令地址 &rarr; MAR

1 &rarr; R，CU发读命令

MEM(MAR) &rarr; MDR，MDR<sub>in</sub>有效

MDR &rarr; Bus &rarr; IR，MDR<sub>out</sub>和IR<sub>in</sub>有效，现行指令 &rarr; IR



#### 执行算术或逻辑运算

比如一条加法指令，微操作序列及控制信号为：

Ad(IR) &rarr; Bus &rarr; MAR，MDR<sub>out</sub>和MAR<sub>in</sub>有效

1 &rarr; R，CU发读命令

MEM(MAR) &rarr; 数据线 &rarr; MDR，MDR<sub>in</sub>有效

MDR &rarr; Bus &rarr; Y，MDR<sub>out</sub>和Y<sub>in</sub>有效，操作数 &rarr; Y

(ACC) + (Y) &rarr; Z，ACC<sub>out</sub>和ALU<sub>in</sub>有效，CU向ALU发送加命令

Z &rarr; ACC，Z<sub>out</sub>和ACC<sub>in</sub>有效，结果 &rarr; ACC



例子：设有如图所示的单总线结构，分析指令ADD(R0)，R1的指令流程和控制信号。

1. 分析指令功能和指令周期

   功能：((R0)) + (R1) &rarr; (R0)

   取指周期、间址周期、执行周期

2. 写出各阶段的指令流程

取指周期：公共操作

| 时序 | 微操作            | 有效控制信号                               |
| ---- | ----------------- | ------------------------------------------ |
| 1    | (PC) &rarr; MAR   | PC<sub>out</sub>，MAR<sub>in</sub>         |
| 2    | M(MAR) &rarr; MDR | MemR，MAR<sub>out</sub>，MDR<sub>in</sub>E |
| 3    | (MDR) &rarr; IR   | MDR<sub>out</sub>，IR<sub>in</sub>         |
| 4    | 指令译码          | -                                          |
| 5    | (PC) +1 &rarr; PC | -                                          |

间址周期：完成取数操作，被加数在主存中，加数已经放在寄存器R1中。

| 时序 | 微操作            | 有效控制信号                               |
| ---- | ----------------- | ------------------------------------------ |
| 1    | (R0) &rarr; MAR   | R0<sub>out</sub>，MAR<sub>in</sub>         |
| 2    | M(MAR) &rarr; MDR | MemR，MAR<sub>out</sub>，MDR<sub>in</sub>E |
| 3    | (MDR) &rarr; Y    | MDR<sub>out</sub>，Y<sub>in</sub>          |

执行周期：相加操作

| 时序 | 微操作              | 有效控制信号                                             |
| ---- | ------------------- | -------------------------------------------------------- |
| 1    | (R1) + (Y) &rarr; Z | R1<sub>out</sub>，ALU<sub>in</sub>，CU向ALU发ADD控制信号 |
| 2    | (Z) &rarr; MDR      | Z<sub>out</sub>，MDR<sub>in</sub>                        |
| 3    | (MDR) &rarr; M(MAR) | MemW，MDR<sub>out</sub>E，MAR<sub>out</sub>              |



### 数据通路-专用数据通路

#### 取指周期

(PC) &rarr; MAR

(MAR) &rarr; 主存

1 &rarr; R，控制单元向主存发送读命令

M(MAR) &rarr; MDR

(MDR) &rarr; IR

(PC) + 1 &rarr; PC

Op(IR) &rarr; CU



### 控制器-硬布线
#### 控制器的功能和工作原理

地址总线（AB）：内存储器、输入设备和输出设备从地址总线接收地址信息。

控制总线（CB）：内存储器、输入设备和输出设备从控制总线得到控制信号。

数据总线（DB）：内存储器、输入设备和输出设备通过数据总线与其他部件传送数据。

输入设备和输出设备通过接口电路与总线相连。

运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据。

控制器部件送出指令地址到地址总线。

控制器部件从数据总线接收指令信息。

控制器部件向系统中的部件提供它们运行所需要的控制信号。



#### 控制器的结构和功能

控制器是计算机系统的指挥中心，控制器的主要功能有：

1. 从主存中取出一条指令，并指出下一条指令在主存中的位置。
2. 对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。
3. 指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。

简称：取指令、分析指令、执行指令。



#### 控制单元的输入和输出



​							指令寄存器IR

​									&darr;

标志，时钟 &rarr; 控制单元CU &larr; 系统总线

​									&uarr;

​							CPU内部控制信号



##### 输入

- 指令寄存器OP(IR) &rarr; CU

  控制信号的产生与操作码有关

- 时钟

  一个时钟脉冲发出一个操作命令或一组需要同时执行的操作命令。

- 标志

  如条件转移指令，根据相应的标志位决定下一步操作。

- 外来信号

  如：中断请求信号INTR

  ​		总线请求信号HRQ

##### 输出

- CPU内部的控制信号

  寄存器之间的数据传输、PC的修改、控制ALU进行的运算

- 到控制总线的控制信号

  到存储器：访存控制信号$\overline{MREQ}$、读命令$\overline{RD}$、写命令$\overline{WR}$

  到I/O设备：访问I/O设备的控制信号$\overline{IO}$

  中断响应信号INTA、总线响应信号HLDA



CU的设计：

1. 硬布线（组合逻辑电路+触发器）
2. 微程序



#### 硬布线控制器



​																		指令寄存器IR

​																				&darr;

​																		操作码译码器

​																				&darr;

​		机器主频（CLK）&rarr;	节拍发生器 &rarr; 控制单元CU &larr; 标志（来自执行单元的反馈信息）

​																				&uarr;

​																	CPU内部控制信号



设计步骤：

1. 分析每个阶段的微操作序列
2. 选择CPU的控制方式
3. 安排微操作时序
4. 电路设计



#### CPU的控制方式

CPU控制方式：产生不同微操作命令序列所用的时序控制方式。

##### 同步控制方式

整个系统所有的控制信号均来自一个统一的时钟信号。

通常以最长的微操作序列和最繁琐的微操作作为标准，采取完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。

同步控制方式的优点是控制电路简单，缺点是运行速度慢。

##### 异步控制方式

异步控制方式不存在基准时标信号。

各部件按自身固有的速度工作，通过应答方式进行联络。

异步控制方式的优点是运行速度快，缺点是控制电路比较复杂。

##### 联合控制方式

对各种不同的指令的微操作实行大部分采用同步控制、小部分采用异步控制方法。



#### 安排操作时序的原则

##### 原则一

微操作的先后顺序不得随意更改。

##### 原则二

被控对象不同的微操作尽量安排在一个节拍内完成。

##### 原则三

占用时间较短的微操作尽量安排在一个节拍内完成，并允许有先后顺序。



#### 安排操作时序

##### 取指周期

| 周期          | 时序及内容             | 备注       |
| ------------- | ---------------------- | ---------- |
| T<sub>0</sub> | (1) PC &rarr; MAR      |            |
| T<sub>0</sub> | (2) 1 &rarr; R         | 发出读信号 |
| T<sub>1</sub> | (3) M(MAR) &rarr; MDR  | 在(1)之后  |
| T<sub>1</sub> | (6) (PC) + 1 &rarr; PC | 在(1)之后  |
| T<sub>2</sub> | (4) MDR&rarr; IR       | 在(3)之后  |
| T<sub>2</sub> | (5) OP(IR) &rarr; ID   | 在(4)之后  |



##### 间址周期

| 周期          | 时序及内容            | 备注 |
| ------------- | --------------------- | ---- |
| T<sub>0</sub> | (1) Ad(IR) &rarr; MAR |      |
| T<sub>0</sub> | (2) 1 &rarr; R        |      |
| T<sub>1</sub> | (3) M(MAR) &rarr; MDR |      |
| T<sub>2</sub> | (4) MDR&rarr; Ad(IR)  |      |



##### 执行周期

非访存指令

1. CLA（clear），ACC清零

   T<sub>0</sub> 

   T<sub>1</sub> 

   T<sub>2</sub>	0 &rarr; AC

2. COM（complement），ACC取反

   T<sub>0</sub> 

   T<sub>1</sub> 

   T<sub>2</sub>	&\overline{AC}& &rarr; AC

3. SHR（shift right），算术右移

   T<sub>0</sub> 

   T<sub>1</sub>	L(AC) &rarr; R(AC)

   T<sub>2</sub>	AC<sub>0</sub> &rarr; AC<sub>0</sub>

4. CSL（cycle shift left），循环左移

   T<sub>0</sub> 

   T<sub>1</sub> 

   T<sub>2</sub>	R(AC) &rarr; L(AC)，AC<sub>0</sub> &rarr; AC<sub>n</sub>

5. STP（stop），停机

   T<sub>0</sub> 

   T<sub>1</sub> 

   T<sub>2</sub>	0 &rarr; G



访存指令

1. ADD（add），加法指令，隐含ACC

   T<sub>0</sub>	Ad(IR) &rarr; MAR, 1 &rarr; R

   T<sub>1</sub>	M(MAR) &rarr; MDR

   T<sub>2</sub>	(AC) + (MDR) &rarr; AC

2. STA X（store acc），存数指令

   T<sub>0</sub>	Ad(IR) &rarr; MAR, 1 &rarr; W

   T<sub>1</sub>	AC &rarr; MDR

   T<sub>2</sub>	MDR &rarr; M(MAR)

3. LDA X（load acc），取数指令

   T<sub>0</sub>	Ad(IR) &rarr; MAR, 1 &rarr; R

   T<sub>1</sub>	M(MAR) &rarr; MDR

   T<sub>2</sub>	MDR &rarr; AC



转移指令

1. JMP X（jump），无条件转移

   T<sub>0</sub>	

   T<sub>1</sub> 

   T<sub>2</sub>	Ad(IR) &rarr; PC

2. BAN X（branch acc negative），条件转移

   T<sub>0</sub> 

   T<sub>1</sub> 

   T<sub>2</sub>	A<sub>0</sub>•Ad(IR) + $\overline{A_0}$•PC &rarr; PC



##### 中断周期

| 周期          | 时序及内容             | 备注       |
| ------------- | ---------------------- | ---------- |
| T<sub>0</sub> | (1) a &rarr; MAR       |            |
| T<sub>0</sub> | (2) 1 &rarr; W         | 发出写信号 |
| T<sub>1</sub> | (3) 0 &rarr; EINT      | 硬件关中断 |
| T<sub>1</sub> | (4) (PC) &rarr; MDR    |            |
| T<sub>2</sub> | (5) MDR&rarr; M(MAR)   | 在(4)之后  |
| T<sub>2</sub> | (6) 向量地址 &rarr; PC | 在(4)之后  |



#### 组合逻辑设计

设计步骤：

- 列出操作时间表
- 写出微操作命令的最简表达式
- 画出逻辑图

##### 列出操作时间表

| 工作周期 | 节拍          | 状态条件                         | 微操作                    | CLA | COM | SHR | CSL | STP | ADD | STA | LDA | JMP | BAN |
| -------- | ------------- | -------------------------------- | ------------------------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| FE取指   | T<sub>0</sub> |                                  | PC &rarr; MAR             | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
|          |               |                                  | 1 &rarr; R                | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
|          | T<sub>1</sub> |                                  | M(MAR) &rarr; MDR         | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
|          |               |                                  | (PC)+1 &rarr; PC          | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
|          | T<sub>2</sub> |                                  | MDR &rarr; IR             | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
|          |               |                                  | OP(IR) &rarr; ID          | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
|          |               | I(间址特征)                      | 1 &rarr; IND              |     |     |     |     |     | 1   | 1   | 1   | 1   | 1   |
|          |               | $\overline{I}$                   | 1 &rarr; EX               | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| IND间址  | T<sub>0</sub> |                                  | Ad(IR) &rarr; MAR         |     |     |     |     |     | 1   | 1   | 1   | 1   | 1   |
|          |               |                                  | 1 &rarr; R                |     |     |     |     |     | 1   | 1   | 1   | 1   | 1   |
|          | T<sub>1</sub> |                                  | M(MAR) &rarr; MDR         |     |     |     |     |     | 1   | 1   | 1   | 1   | 1   |
|          | T<sub>2</sub> |                                  | MDR &rarr; Ad(IR)         |     |     |     |     |     | 1   | 1   | 1   | 1   | 1   |
|          |               | $\overline{IND}$（间址周期标志） | 1 &rarr; EX               |     |     |     |     |     | 1   | 1   | 1   | 1   | 1   |
| EX执行   | T<sub>0</sub> |                                  | Ad(IR) &rarr; MAR         |     |     |     |     |     | 1   | 1   | 1   |     |     |
|          |               |                                  | 1 &rarr; R                |     |     |     |     |     | 1   |     | 1   |     |     |
|          |               |                                  | 1 &rarr; W                |     |     |     |     |     |     | 1   |     |     |     |
|          | T<sub>1</sub> |                                  | M(MAR) &rarr; MDR         |     |     |     |     |     | 1   |     | 1   |     |     |
|          |               |                                  | AC &rarr; MDR             |     |     |     |     |     |     | 1   |     |     |     |
|          | T<sub>2</sub> |                                  | (AC)+(MDR) &rarr; AC      |     |     |     |     |     | 1   |     |     |     |     |
|          |               |                                  | MDR &rarr; M(MAR)         |     |     |     |     |     |     | 1   |     |     |     |
|          |               |                                  | MDR &rarr; AC             |     |     |     |     |     |     |     | 1   |     |     |
|          |               |                                  | 0 &rarr; AC               | 1   |     |     |     |     |     |     |     |     |     |
|          |               |                                  | $\overline{AC}$ &rarr; AC |     | 1   |     |     |     |     |     |     |     |     |
|          |               |                                  | Ad(IR) &rarr; PC          |     |     |     |     |     |     |     |     | 1   |     |
|          |               | A<sub>0</sub>                    | Ad(IR) &rarr; PC          |     |     |     |     |     |     |     |     |     | 1   |



##### 写出微操作命令的最简表达式

M(MAR) &rarr; MDR 微操作命令的逻辑表达式：

FE•T<sub>1</sub> + IND•T<sub>1</sub>(ADD+STA+LDA+JMP+BAN) + EX•T<sub>1</sub>(ADD+LDA)

= T<sub>1</sub>{FE+IND(ADD+STA+LDA+JMP+BAN)+EX(ADD+LDA)}



##### 画出逻辑图



#### 硬布线控制器小结

设计步骤：

1. 分析每个阶段的微操作序列
2. 选择CPU的控制方式
3. 安排微操作时序
4. 电路设计
   - 列出操作时间表
   - 写出微操作命令的最简表达式
   - 画出逻辑图



### 控制器-微程序
#### 控制器的功能和工作原理
硬布线工作原理：微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即使产生。

微程序工作原理：事先把微操作控制信号存储在一个专门的存储器（控制存储器）中，将每一条机器指令编写成一个微程序，这些微程序可以存到一个控制存储器中，用寻址用户程序机器指令的办法来寻址每个微程序中的微指令。


#### 微程序的基本思想

完成一条机器指令 

= 微操作命令1 + 微操作命令2+ ... + 微操作命令n

= 微指令1 + ... 微指令n

= 微指令



微操作命令，即微命令，是微操作的控制信号。微操作是微命令的执行过程。

相容性微命令：可以同时产生、共同完成某一些微操作的微命令。

互斥性微命令：在机器中不允许同时出现的微命令。



一条机器指令对应一个微程序。

微指令的基本格式 = 操作控制（微操作码） + 顺序控制（微地址码）



每条指令取指周期的操作是相同的，所以将取指操作的微命令统一编成一个微程序，而每条机器指令所对应的具体操作再单独编写一个对应的微程序。



#### 微程序控制器的基本结构

##### 控制存储器CM

用于存放各指令对应的微程序，控制存储器可用只读存储器ROM构成。

##### 地址译码

将地址码转化为存储单元控制信号。

##### CMAR

微地址寄存器，接收微地址形成部件送来的微地址，为在CM中读取微指令作准备。

##### CMDR

用于存放从CM中取出的微指令，它的位数同微指令字长相等。

##### 微指令形成部件

产生初始微地址和后继微地址，以保证微指令的连续执行。

##### 顺序逻辑

标志和CLK



#### 控制存储器

| M                | M+1 | 取指周期微程序  |
| ---------------- | --- | --------------- |
| M+1              | M+2 | 取指周期微程序  |
| M+2              | M+3 |                 |
| ...              |     | 间址周期微程序  |
| 转执行周期微指令 |     |                 |
| ...              |     | 中断周期微程序  |
| 转取指周期微指令 |     |                 |
| P                | P+1 | LDA操作的微程序 |
| P+1              | P+2 |                 |
| P+2              | M   |                 |
| K                | K+1 | STA操作的微程序 |
| K+1              | K+2 |                 |
| K+2              | M   |                 |

取指周期微程序，默认是公共的，故如果某指令系统中有n条机器指令，则CM中微程序的个数至少是n+1个。

间址周期和中断周期微程序，不一定是公共的，此处做成公共的，故如果这台计算机指令系统中有n条机器指令，则CM中微程序的个数是n+3个。



#### 微指令的格式

##### 水平型微指令

一次能定义执行多个并行操作。

基本格式：操作控制 + 顺序控制

优点：微程序短，执行速度快。

缺点：微指令长，编写程序较麻烦。



##### 垂直型微指令

类似机器指令操作码的方式，由微操作码规定微指令的功能。

基本格式：微操作码(uOP) + 目的地址(Rd) + 源地址(Rs)

优点：微指令短、简单、规整，便于编写微程序。

缺点：微程序长，执行速度慢，工作效率低。



##### 混合型微指令

在垂直型的基础上增加一些不太复杂的并行操作。

微指令较短，仍便于编写。

微程序也不长，执行速度加快。



#### 微指令的编码方式

微指令的编码方式有称为微指令的控制方式，它是指如何对微指令的控制字段进行编码，以形成控制信号。编码的目标是在保证速度的情况下，尽量缩短微指令字长。

##### 水平型微指令

1. 直接编码（直接控制）方式

   在微指令的操作控制字段中，每一位代表一个微操作命令，某位为“1”表示该控制信号有效。

   优点：简单、直观、执行速度快，操作并行性好。

   缺点：微指令字长过长，n个微命令就要求微指令的操作字段有n位，造成控存容量极大。										

   | 1，(PC) &rarr; MAR | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1，1 &rarr; R | 下地址 |
   | ------------------ | --- | --- | --- | --- | --- | --- | --- | --- | --- | ------------- | ------ |

2. 字段直接编码方式

   将微指令的控制字段分成若干“段”，每段经译码后发出控制信号。

   微命令字段分段的原则：

   - 互斥性微命令分在同一段内，相容性微命令分在不同段内。
   - 每个小段中包含的信息位不能太多，否则将增加译码线路的复杂性和译码时间。
   - 一般每个小段还要留出一个状态，表示本字段不发出任何微命令。因此，当某字段的长度为3位时，最多只能表示7个互斥的微命令，通常用000表示不操作。

   | 001，(PC) &rarr; MAR | 00...0 | 111，1 &rarr; R | 下地址 |
   | -------------------- | ------ | --------------- | ------ |

​		优点：可以缩短微指令字长

​		缺点：要通过译码电路后再发出微命令，因此比直接编码方式慢。

3. 字段间接编码方式

   一个字段的某些微命令需由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微命令，故称为字段间接编码，又称隐式编码。

   优点：可进一步缩短微指令字长。

   缺点：削弱了微指令的并行控制能力，故通常作为字段直接编码方式的一种辅助手段。

   

#### 微指令的地址形成方式

1. 微指令的下地址字段指出

   微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继指令的地址，这种方式又称为断定方式

2. 根据机器指令的操作码形成

   当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成

3. 增量计数器法（CMAR）+ 1 &rarr; CMAR

4. 分支转移

   转移方式：指明判别条件。

   转移地址：指明转移成功后的去向。

   操作控制字段 + 转移方式 + 转移地址

5. 通过测试网络

6. 由硬件产生微程序入口地址

   第一条微指令地址由专门硬件产生

   中断周期由硬件产生中断周期微程序首地址



#### 微程序控制的基本概念

1. 微命令与微操作

   微命令是微操作的控制信号

   微操作是微命令的执行过程

2. 微指令与微周期

   微指令是若干微命令的集合

   微周期通常指从控制存储器中读取一条微指令并执行相应的微操作所需的时间。

3. 主存储器与控制存储器

   主存储器用于存放程序和数据，在CPU外部，用RAM实现。

   控制存储器(CM)，用于存放微程序，在CPU内部，用ROM实现。

4. 程序与微程序

   程序是指令的有序集合，用于完成特定的功能。

   微程序是微指令的有序集合，一条指令的功能由一段微程序来实现。



#### 微程序控制单元的设计

设计步骤：

1. 分析每个阶段的微操作序列
2. 写出对应机器指令的微操作命令及节拍安排
3. 确定微指令格式
4. 编写微指令码点



##### 取指周期-微程序控制器的节拍安排

| 周期          | 时序及内容                   | 备注 |
| ------------- | ---------------------------- | ---- |
| T<sub>0</sub> | PC &rarr; MAR                | (1)  |
| T<sub>0</sub> | 1 &rarr; R                   |      |
| T<sub>1</sub> | Ad(CMDR) &rarr; CMAR         |      |
| T<sub>2</sub> | M(MAR) &rarr; MDR            | (2)  |
| T<sub>2</sub> | (PC) + 1 &rarr; PC           |      |
| T<sub>3</sub> | Ad(CMDR) &rarr; CMAR         |      |
| T<sub>4</sub> | MDR&rarr; IR                 | (3)  |
| T<sub>4</sub> | OP(IR) &rarr; 微地址形成部件 |      |
| T<sub>5</sub> | OP(IR) &CMAR                 |      |

总共由3条微指令组成



#### 微程序设计的分类

1. 静态微程序设计和动态微程序设计

   静态：微程序无需改变，采用ROM

   动态：通过改变微指令和微程序改变机器指令有利于仿真，采用EPROM

2. 毫微程序设计

   毫微程序设计的基本概念

   微程序设计用微程序解释机器指令

   毫微程序设计用毫微程序解释程序

   毫微指令与微指令的关系好比微指令与机器指令的关系



#### 硬布线与微程序的比较

| 类别     | 微程序控制器                                                         | 硬布线控制器                                                       |
| -------- | -------------------------------------------------------------------- | ------------------------------------------------------------------ |
| 工作原理 | 微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可。 | 微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生 |
| 执行速度 | 慢                                                                   | 快                                                                 |
| 规整性   | 较规整                                                               | 繁琐、不规整                                                       |
| 应用场合 | CISC、CPU                                                            | RISC、CPU                                                          |
| 易扩充性 | 易扩充修改                                                           | 困难                                                               |



### 指令流水线概念及性能指标

#### 指令流水的定义

设取指、分析、执行3个阶段的时间都相等，用t表示，按以下几种执行方式分析n条指令的执行时间。

1. 顺序执行方式

   取指k &rarr; 分析k &rarr; 执行k &rarr; 取指k+1 &rarr; 分析k+1 &rarr; 执行k+1 ... 取指k+n &rarr; 分析k+n &rarr; 执行k+n

   总耗时T = n x 3t = 3nt

   传统冯•诺伊曼机采用顺序执行方式，又称串行执行方式。

   优点：控制简单，硬件代价小。

   缺点：执行指令的速度缓慢，在任何时刻，处理机中只有一条指令在执行，各功能部件的利用率很低。

2. 一次重叠执行方式

   取指k &rarr; 分析k &rarr; 执行k 

   ​								取指k+1 &rarr; 分析k+1 &rarr; 执行k+1 

   ​						...

   ​																		取指k+n &rarr; 分析k+n &rarr; 执行k+n

    总耗时T = 3t + (n-1) x 2t = (1 + 2n)t

   优点：程序执行时间缩短了1/3，各功能部件的利用率明显提高。

   缺点：需要付出硬件上较大的开销代价，控制过程也比顺序执行复杂了。

3. 二次重叠执行方式

   取指k &rarr; 分析k &rarr; 执行k 

   ​				取指k+1 &rarr; 分析k+1 &rarr; 执行k+1 

   ​						...

   ​									取指k+n &rarr; 分析k+n &rarr; 执行k+n

    总耗时T = 3t + (n-1) x t = (2 + n)t

   优点：与顺序执行方式相比，指令的执行时间缩短了近2/3，在理想情况下，处理机中同时有3条指令在执行。



注：也可以把每条指令的执行过程分成4个或5个阶段，分成5个阶段是比较常见的做法。



#### 指令流水的表示方法

1. 指令执行过程图

   主要用于分析指令的执行过程以及影响流水线等因素

2. 时空图

   不同的阶段所对对应的不同的硬件资源

   主要用于分析流水线的性能



#### 流水线的性能指标

##### 吞吐率

吞吐率是指在单位时间内流水线所完成的任务数量，或是输出结果的数量。

设任务数量为n；处理完成n个任务所用的时间为T<sub>k</sub>，则计算流水线吞吐率(TP)的最基本的公式为：
$$
TP = \frac{n}{T_k} \\[2ex]
一条指令的执行分为k个阶段，每个阶段耗时\Delta{t}，一般取\Delta{t} = 一个时钟周期。 \\[2ex]
T_k = (k+n-1)\Delta{t} \\[2ex]
流水线的实际吞吐量为：\\[2ex]
TP = \frac{n}{(k+n-1)\Delta{t}} \\[2ex]
当连续输入的任务n \rightarrow \infty，得最大吞吐率为TP_max = 1/\Delta{t}
$$




##### 加速比

完成同样的一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。

设T<sub>0</sub>表示不使用流水线时的执行时间，即顺序执行所用的时间，T<sub>k</sub>表示使用流水线时的执行时间，则计算流水线加速比（S）的基本公式为：
$$
S = \frac{T_0}{T_k} \\[2ex]
一条指令的执行分为k个阶段，每个阶段耗时\Delta{t}，一般取\Delta{t} = 一个时钟周期。 \\[2ex]
单独完成一个任务耗时为k\Delta{t}，则顺序完成n个任务耗时T_0 =nk\Delta{t}，
T_k = (k+n-1)\Delta{t} \\[2ex]
S = \frac{kn\Delta{t}}{(k+n-1)\Delta{t}} = \frac{kn}{k+n-1} \\[2ex]
当连续输入的任务n \rightarrow \infty，得最大加速度比S_max = k
$$


##### 效率

流水线的设备利用率称为流水线的效率，在时空图上，流水线的效率定义完成n个任务占用的时空区有效面积与n个任务所用的时间与k个流水段所围成的时空区总面积之比。则流水线效率（E）的一般公式为：
$$
E = \frac{n个任务占用k时空区有效面积}{n个任务所用的时间与k个流水段所围成的时空区总面积} = \frac{T_0}{kT_k} \\[2ex]
一条指令的执行分为k个阶段，每个阶段耗时\Delta{t}，一般取\Delta{t} = 一个时钟周期。 \\[2ex]
当连续输入的任务n \rightarrow \infty，得最高效率E_max = 1
$$


#### 影响流水线的因素及分类

##### 机器周期的设置

为了方便流水线的设计，将每个阶段的耗时取成一样，以最长耗时为准。

流水线每一个功能段部件后面都要有一个缓冲寄存器，或称为锁存器，其作用是保存本流水段的执行结果，提供给下一流水段使用。



##### 影响流水线的因素

1. 结构相关（资源冲突）
2. 数据相关（数据冲突）
3. 控制相关（控制冲突）



##### 结构相关

由于多条指令在同一时刻争用统一资源而形成的冲突称为结构相关。

解决办法：

- 后一相关指令暂停一周期
- 资源重复配置：数据存储器 + 指令存储器



##### 数据相关

数据相关指令在一个程序中，存在必须等前一条指令完才能执行后一条指令的情况，则这两条指令即为数据相关。

解决办法：

1. 把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。可分为硬件阻塞（stall）和软件插入（NOP）两种方法。
2. 数据旁路技术
3. 编译优化：通过编译器调整指令顺序来解决数据相关。



数据的基本操作：读（R）、写（W）

冲突的基本类型：

- RAW 写后读
- WAR 读后写
- WAW 写后写



##### 控制相关

当流水线遇到转移指令和其他改变PC值当指令而造成断流时，会引起控制相关。

解决办法：

1. 尽早判别转移是否发生，尽早生成转移目标地址。
2. 预取转移成功和不成功两个控制流方向上的目标指令。
3. 加快和提前形成条件码。
4. 提高转移方向的猜准率。



#### 流水线的分类

##### 部件功能级、处理机级和处理机间级流水线

根据流水线使用的级别的不同，流水线可分为部件功能级流水线、处理机级流水线和处理机间流水线。

部件功能级：

​	就是将复杂的算术逻辑运算组成流水线工作方式。例如，可将浮点加法操作分成求阶差、对阶、尾数相加以及结果规格化等4个子过程。

处理机级：

​	是一种宏流水，其中每一个处理机完成某一专门任务，各个处理机所得到的结果需存放在与下一个处理机所共享的存储器中。



##### 单功能和多功能流水线

按流水线可以完成的功能，流水线可分为单功能流水线和多功能流水线。

单功能流水线，是指只能实现一种固定的专门功能的流水线。

多功能流水线，是指通过各段不同的连接方式以同时或不同时实现多种功能的流水线。



##### 动态流水线和静态流水线

按同一时间内各段之间的连接方式，流水线可分为静态流水线和动态流水线。

静态流水线指在同一时间内，流水线的各段只能按同一种功能的连接方式工作。

动态流水线指在同一时间内，当某些段正在实现某种运算时，另一段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得复杂。



##### 线性流水线和非线性流水线

按流水线的各个功能段之间是否有反馈信号，流水线可分为线性流水线与非线性流水线。

线性流水线中，从输入到输出，每个功能段只允许经过一次，不存在反馈回路。

非线性流水线存在反馈回路，从输入到输出过程中，某些功能段将数次通过流水线，这种流水线适合进行线性递归的运算。



#### 流水线的多发技术

##### 超标量技术

每个周期内可并发多条独立指令

要配置多个功能部件

不能调整指令的执行顺序

通过编译优化技术，把可并行执行的指令搭配起来。



##### 超流水技术

在一个时钟周期内再分段

在一个时钟周期内一个功能部件使用多次

不能调整指令的执行顺序

靠编译程序解决优化问题。

流水线的速度是普通流水线的n倍。



##### 超长指令字

由编译程序挖掘出指令间潜在的并行性，将多条能并行操作的指令组合成一条，具有多个操作码字段的超长指令字（可达几百位），采用多个处理部件。



## 第六章
总线

### 总线的概念与分类

#### 总线的特点

总线是一组能为多个部件分时共享的公共信息传递线路。

- 共享是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享。
- 分时是指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时的向总线发送信息。



为什么要用总线？

早起计算机外接设备时大多采用分散连接方式，不易实现随时增减外部设备。为了更好地解决I/O设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。



#### 总线的特性

1. 机械特性

   尺寸、形状、管脚数、排列顺序

2. 电气特性

   传输方向和有效的电平范围

3. 功能特性

   每根传输线的功能（地址、数据、控制）

4. 时间特性

   信号的时序关系



#### 总线的分类-按数据传输格式

##### 串行总线

优点：只需要一条传输线，成本低廉，广泛应用于长距离传输；应用于计算机内部时，可以节省布线空间。

缺点：在数据发送和接收的时候要进行拆卸和装配，要考虑串行-并行转换的问题。

##### 并行总线

优点：总线逻辑时序比较简单，电路实现起来比较容易。

缺点：信号线数量多，占用更多的布线空间；远距离传输成本高昂；由于工作频率较高时，并行的信号线之间会产生严重干扰，对每条线等长的要求也越高，所以无法持续提升工作频率。



注：

1. 工作频率相同时，串行总线传输速度比并行总线慢。
2. 并行总线的工作频率无法持续提高，而串行总线可以通过不断提高工作频率来提高传输速度，最终超过并行总线。



#### 总线的分类-按总线功能

##### 片内总线

片内总线时芯片内部的总线，它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线。



##### 系统总线

系统总线是计算机系统内各部件（CPU、主存、I/O接口）之间互相连接的总线。

按系统总线传输信息内容的不同，又可分为3类：

- 数据总线
  - 传输各功能部件之间的数据信息，包括指令和操作数；
  - 位数（根数）与机器字长、存储字长有关
  - 双向
- 地址总线
  - 传输地址信息，包括主存单元或I/O端口的地址
  - 位数（根数）与主存地址空间大小及设备数量有关
  - 单向
- 控制总线
  - 传输控制信息
  - 一根控制线传输一个信号
    - 有出：CPU送出控制命令
    - 有入：主存（或外设）返回CPU的反馈信号



##### 通信总线

通信总线是用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间信息传送的总线，通信总线也称为外部总线。



#### 系统总线的结构

##### 单总线结构

结构：CPU、主存、I/O设备（通过I/O接口）都连接在一组总线上，允许I/O设备之间、I/O设备和PC之间或I/O设备与主存之间直接交换信息。

优点：结构简单，成本低，易于接入新的设备

缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作。

注：单总线不是指只有一根信号线，系统总线按传送信息的不同可以细分为地址总线、数据总线和控制总线。



##### 双总线结构

结构：双总线结构有两条总线，一条是主存总线，用于CPU、主存和通道之间进行数据传送，另一条是I/O总线，用于多个设备与通道之间进行数据传送。

优点：将较低速的I/O设备从单总线上分离出来，实现存储器总线和I/O总线分离。

缺点：需要增加通道等硬件设备。

通道：是具有特殊功能的处理器，能对I/O设备进行统一的管理。通道程序存放在主存中。



##### 三总线结构

结构：三总线结构在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为：主存总线、I/O总线和直接内存访问DMA总线。

优点：提高了I/O设备的性能，使其更快的响应命令，提高系统吞吐量。

缺点：系统工作效率较低。

DMA总线：Direct Memory Access，直接访问内存。



### 总线的性能指标

1. 总线的传输周期（总线周期）
2. 总线时钟周期
3. 总线工作频率
4. 总线的时钟频率
5. 总线宽度
6. 总线带宽
7. 总线复用
8. 信号线数

##### 总线的传输周期（总线周期）

一次总线操作所需的时间（包括申请阶段、寻址阶段、传输阶段和结束阶段），通常由若干个总线时钟周期构成。

##### 总线时钟周期

即机器的时钟周期。计算机有一个统一的时钟，以控制整个计算机各个部件，总线也要受此时钟的控制。

##### 总线的工作频率

总线上各种操作的频率，为总线周期的倒数。

若总线周期=N个时钟周期，则总线的工作频率=时钟频率/N。

实际上指一秒内传送几次数据。

##### 总线的时钟频率

即机器的时钟频率，为时钟周期的倒数。

若时钟周期为$\\pi$，则时钟频率为1/$\pi$。

实际上指一秒内有多少个时钟周期。



##### 总线宽度

又称总线位宽，它是总线上同时能够传输的数据位数，通常是指数据总线的根数，如32根称为32位（bit）总线。

##### 总线带宽

可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒（B/s）表示。
$$
总线带宽 = 总线工作频率\cdot总线宽度（bit/s） = 总线工作频率 \cdot \frac{总线宽度}{8}（B/s） = \frac{总线宽度}{总线周期}（bit/s） = \frac{总线宽度}{8 \cdot 总线周期}（B/s）
$$
注：总线带宽是指总线本身所能达到的最高传输速率，在计算实际的有效数据传输时，要用实际传输的数据量除以耗时。



- Kilo（10<sub>3</sub>）

- Mega（10<sub>6</sub>）
- Giga（10<sub>9</sub>）
- Tera（10<sub>12</sub>）

1s = 10<sub>9</sub>n

例子: 某同步总线采用数据线和地址线复用方式，其中地址/数据线有32根，总线时钟频率为66MHz，每个时钟周期传送两次数据（上升沿和下降沿各传送一次数据）。

1. 该总线的最大数据传输率（总线带宽）是多少？
2. 若该总线支持突发（猝发）传输方式，传输一个地址占用一个时钟周期，则一次“主存写”总线事务传输128位数据所需要的时间至少是多少？

解答：

1. 每个时钟周期传送两次数据，则总线工作频率是时钟频率的两倍。

   总线工作频率 = 2 x 66MHz = 132MHz

   总线宽度 = 32bit = 4B

   总线带宽 = 总线工作频率 x 总线宽度 = 132 x 4MB/s = 528MB/s

2. 突发（猝发）传输方式：一次总线事务中，主设备只需给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据。

   发送首地址占用1个时钟周期，128位数据需传输4次，占用2个时钟周期

   一个时钟周期 = 1/66MHz 约= 15ns

   总耗时 = (1 +2 ) x 15ns = 45ns



### 总线仲裁

#### 总线仲裁的基本概念

同一时刻只能有一个设备控制总线传输操作，可以有一个或多个设备从总线接收数据。

将总线上所连接的各类设备按其对总线有无控制功能分为：

- 主设备：获得总线控制权的设备
- 从设备：被主设备访问的设备，只能响应从主设备发来的各种命令。

为什么要仲裁？

总线作为一种共享设备，不可避免的会出现同一时刻有多个主设备竞争总线控制权的问题。

总线仲裁分类：

- 集中仲裁方式：链式查询方式、计数器顶式查询方式、独立请求方式
- 分布仲裁方式



#### 集中仲裁方式

##### 工作流程

1. 主设备发出请求信号
2. 若多个主设备同时要使用总线，则由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定那个主设备能使用总线。
3. 获得总线控制权的主设备开始传送数据。



##### 链式查询方式

新增三根线：

- BG：总线允许
- BR：总线请求
- BS：总线忙

总线忙信号的建立者是获得总线控制权的设备。

优先级：

离总线控制器越近的部件，其优先级越高。

离总线控制器越远的部件，其优先级越低。

优点：

链式查询方式优先级固定，只需用很少的几根控制线就能按一定优先次序实现总线控制，结构简单，扩充容易。

缺点：

对硬件电路的故障敏感，并且优先级不能改变。当优先级高的部件频繁请求使用总线时，会使优先级较低的部件长期不能使用总线。



##### 计数器查询方式

当地址线上的技术值与请求使用总线设备地址一致时，该设备获得总线控制权，同时，中止计数器的技术及查询。

当总线控制器接收到总线请求信号，判断总线空闲时，计数器开始计数，计数值通过设备地址线发向各个部件。

结构特点：

用一个计数器控制总线使用权，相对链式查询方式多了一组设备地址线，少了一根总线响应线BG，它仍共用一根总线请求线。

优点：

1. 计数初始值可以改变优先次序
   - 计数每次从“0”开始，设备的优先级就按顺序排列，固定不变。
   - 计数从上一次的终点开始，此时设备使用总线的优先级相等。
   - 计数器的初始值还可以由程序设置。

2. 对电路的故障没有链式敏感

缺点：

1. 增加了控制线数，若设备有n个，则需log<sub>2</sub>n + 2条控制线
2. 控制相对比链式查询相对复杂



##### 独立请求方式

当总线上的部件需要使用总线时，经各自的总线请求线发送总线请求信号，在总线控制器中排队。

当总线控制器按一定的优先次序决定批准某个部件的请求时，则给该部件发送总线响应信号。

优点：

1. 响应速度快，总线允许信号BG直接从控制器发送到有关设备，不必在设备间传递或者查询。
2. 对优先次序的控制相当灵活。

缺点：

1. 控制线数量多

   若设备有n个，则需要2n+1条控制线，其中+1为BS线，其用处为，用于设备向总线控制部件反馈已经使用完毕总线。

2. 总线的控制逻辑更加复杂。



#### 集中总裁方式小结

| 对比项目 | 链式查询                               | 计数器定时查询                                                         | 独立请求                                  |
| -------- | -------------------------------------- | ---------------------------------------------------------------------- | ----------------------------------------- |
| 控制线数 | 3，总线请求：1；总线允许：1；总线忙：1 | log<sub>2</sub>n+2，总线请求：1；总线允许：log<sub>2</sub>n；总线忙：1 | 2n+1，总线请求：n；总线允许：n；总线忙：1 |
| 优点     | 优先级固定，结构简单，扩充容易         | 优先级较灵活                                                           | 响应速度快，优先级灵活                    |
| 缺点     | 对电路故障敏感优先级不灵活             | 控制线较多，控制相对复杂                                               | 控制线多，控制复杂                        |

总线忙信号的建立者是获得总线控制权的设备



### 总线的操作和定时

#### 总线传输的四个阶段

##### 总线周期的四个阶段

1. 申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者。也可将此阶段细分为传输请求和总线仲裁两个阶段。
2. 寻址阶段：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块。
3. 传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送。
4. 结束阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权。



##### 总线定时

是指总线在双方交换数据的过程中需要时间上配合关系的控制，这种控制称为总线定时，它的实质是一种协议或规则。

- 同步通信（同步定时方式）

  由统一时钟控制数据传送

- 异步通信（异步定时方式）

  采用应答方式，没有公共时钟标准

- 半同步通信

  同步、异步结合

- 分离式通信

  充分挖掘系统总线每瞬间的潜力



#### 同步定时方式

同步定时方式是指系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。

时钟产生相等的时间间隔，每个间隔构成一个总线周期。

在一个总线周期中，发送方和接收方可进行一次数据传送。

因为采用统一时钟，每个部件或设备发送或接收信息都在固定的总线传送周期中，一个总线的传送周期结束，下一个总线传送周期开始。

优点：传送速度快，具有较高的传输速率，总线控制逻辑简单。

缺点：主从设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差。

同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。



#### 异步定时方式

在异步定时方式中，没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制。

主设备提出交换信息的“请求”信号，经接口传送到从设备；从设备接到主设备的请求后，通过接口向主设备发出“回答”信号。

根据“请求”和“回答”信号的撤销是否互锁，分为以下3种类型。

- 不互锁方式
- 半互锁方式
- 全互锁方式



##### 不互锁方式

主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号。

而从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，自动撤销“回答信号”。双方不存在互锁关系。

##### 半互锁方式

主设备发出“请求”信号后，必须待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。

而从设备在接到“请求”信号后，发出“回答”信号，单不必等待获知主设备的“请求”信号已经撤销，而是隔一段四件后自动撤销“回答”信号，不存在互锁关系。

##### 全互锁方式

主设备发出“请求”信号后，必须待从设备“回答”后，才撤销“请求”信号。

从设备发出“回答”信号，必须待获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系。

优点：

总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠的进行信息交换，自动适应时间的配合。

缺点：

比同步控制方式稍复杂一些，速度比同步定时方式慢。



##### 数据传输率

波特率：单位时间内传送的二进制数据的位数，单位用bps（位/秒）表示，记做波特。

比特率：单位时间内传送二进制有效数据的位数，单位用bps表示，bps即bit/s
$$
\frac{比特率}{波特率} = \frac{数据位数}{数据位数+其他附加位位数}
$$
例子：

在异步串行传输方式下，其实位为1位，数据传输位为7位，偶校验位为1位，停止位为1位，如果波特率为1200bit/s，求这是的有效数据传输率为多少？

解答：

每传送(1+7+1+1) = 10个二进制位，就传送了7个有效数据位，故有效数据传输率为1200 x 7 / 10 = 840bit/s



#### 半同步信号

统一时钟的基础上，增加一个“等待”响应信号$\overline{WAIT}$



#### 分离式通信

上述三种通信的共同点

一个总线传输周期（以输入数据为例）

- 主模块发地址、命令，使用总线
- 从模块准备数据，不使用总线，总线空闲
- 从模块向主模块发数据，使用总线



分离式通信的一个总线传输周期分为

- 子周期1：主模块申请占用总线，使用完后放弃总线的使用权
- 子周期2：从模块申请占用总线，将各种信息送至总线上



特点：

1. 各模块均有权申请占用总线
2. 采用同步方式通信，不等对方回答
3. 各模块准备数据时，不占用总线
4. 总线利用率提高



### 总线标准

总线标准是国际上公布或推荐的互连各个模块的标准，它是把各种不同的模块组成计算机系统时必须遵守的规范。按总线标准设计的借口可视为通用接口，在接口的两端，任何一方只需根据总线标准的要求完成自身方面的功能要求，而无需了解对方接口的要求。

系统总线标准：ISA、EISA、VESA、PCI、PCI-Express等

设备总线标准：IDE、AGP、RS-232C、USB、SATA、SCSI、PCMCIA等。

局部总线标准：在ISA总线和CPU总线之间增加的一级总线或管理层，如PCI、PCI-E、VESA、AGP等，可以节省系统的总带宽。



- 即插即用

- 热插拔



## 第七章
输入输出系统

### I/O系统基本概念

####  I/O系统演变过程

##### 早期

CPU和I/O串行工作，分散连接

程序查询方式：

由CPU通过程序不断查询I/O设备是否已做好准备，从而控制I/O设备与主机交换信息。

##### 接口模块和DMA阶段

CPU和I/O并行工作，总线连接

中断方式：

只在I/O设备准备就绪并向CPU发出中断请求时才予以响应。

DMA方式：

主存和I/O设备之间有一条直接数据通路，当主存和I/O设备交换信息时，无需调用中断服务程序。

##### 具有I/O通道结构的阶段

在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I/O命令时，只需启动有关通道，通道将执行通路程序，从而完成I/O操作。

##### 具有I/O处理机阶段



#### I/O系统基本组成

##### I/O软件

包括驱动程序、用户程序、管理程序、升级补丁等。

通常采用I/O指令和通道指令实现CPU和I/O设备的信息交换。

- I/O指令

  CPU指令的一部分

  组成：操作码 + 命令码 + 设备码

  操作码：识别I/O指令

  命令码：做什么操作

  设备码：对哪个设备进行操作

-  通道指令

  通道指令自身的指令

  指出数据的首地址、传送字数、操作命令

  通道指令放在主存中

  由CPU执行启动I/O设备的指令，由通道代替CPU对I/O设备进行管理

##### I/O硬件

包括外部设备、设备控制器和接口、I/O总线等。



#### I/O方式简介

##### 程序查询方式

I/O与CPU串行，CPU有踏步等待现象

##### 程序中断方式

I/O准备数据时CPU继续工作，在指令执行借宿时响应中断

##### DMA方式

主存与I/O交换信息时由DMA控制器控制，主存取周期结束时响应DMA请求

##### 通道方式

通过I/O指令启动通道，通道程序放在主存中



程序查询/中断方式主要由程序控制，用于速度较低的外设

DMA/通道方式主要由硬件控制，用于速度较高的外设



### 输入与输出

#### 外部设备

外部设备也称外围设备，是除了主机以外的、能直接或间接与计算机交换信息的装置。

##### 输入设备

用于向计算机系统输入命令和文本、数据等信息的部件。键盘和鼠标是最基本的输入设备。

##### 输出设备

用于将计算机系统中的信息输出到计算机外部进行显示、交换等的部件。显示器和打印机是最基本的输出设备。

##### 外存设备

是指除计算机内存及CPU缓存等以外的存储器。硬磁盘、光盘等是最基本的外存设备。



#### 显示器的分类

- 阴极射线管（CRT）显示器
- 液晶显示器
- LED（发光二极管）显示器



#### 显示器的指标

##### 屏幕大小

以对角线长度表示，常用的有12-29英寸等

##### 分辨率

所能表示的像素个数，屏幕上的每一个光点就是一个像素，以宽、高的像素的乘积表示，例如，800x600、1024x768和1280x1024等。

##### 灰度级

灰度级是指黑白显示器中所显示的像素点的亮暗差别，在彩色显示器中则表现为颜色的不同，灰度级越多，图像层次越清楚逼真，典型的有8位（256级）、16位等。n位可以表示2<sub>n</sub>种不同的亮度或颜色。

##### 刷新

光点只能保持极短的时间便会消失，为此必须在光点消失之前再重新扫描显示一遍，这个过程称为刷新。

刷新频率：单位时间内扫描整个屏幕内容的次数，按照人的视觉生理，刷新频率大于30Hz时才不会感到闪烁，通常显示器刷新频率在60-120Hz。

##### 显示存储器VRAM

也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。其中存储容量由图像分辨率和灰度级决定，分辨率越高，刷新存储器容量越大。

VRAM容量 = 分辨率 x 灰度级位数

VRAM带宽 = 分辨率 x 灰度级位数 x 帧数



#### 阴极射线管（CRT）显示器

##### 按显示信息内容不同

- 字符显示器
- 图形显示器
- 图像显示器



##### 按扫描方式不同可分为

- 光栅扫描显示器
- 随机扫描显示器



#### 打印机

打印机时计算机的输出设备之一，用于将计算机处理结果打印在相关介质上。

##### 按印字原理不同可分为

- 击打式打印机

  利用机械动作使印字机构与色带和纸相撞而打印字符

  优点：设备成本低、印字质量好

  缺点：噪声大，速度慢

- 非击打式打印机

  采用电、磁、光、喷墨等物理、化学方法来印刷字符

  优点：速度快、噪声小

  缺点：成本高

##### 按打印机工作方式不同可分为

- 串行打印机

  逐字打印，速度慢

- 行式打印机

  逐行打印，速度快



##### 按工作方式可分为

- 针式打印机
- 喷墨式打印机
- 激光打印机



### 外存储器

计算机等外存储器又称辅助存储器，目前主要使用磁表面存储器。

所谓磁表面存储，是指把某些磁性材料薄薄的涂在金属铝或塑料表面上作为载磁体来存信息。磁盘存储器、磁带存储器和磁鼓存储器均属于磁表面存储器。

##### 磁表面存储器的优点：

1. 存储容量大，价位低
2. 记录介质可以重复使用
3. 记录信息可以长期保存而不丢失，甚至可以脱及存档
4. 非破坏性读出，读出时不需要再生

##### 磁表面存储器的缺点：

1. 存取速度慢
2. 机械结构复杂
3. 对工作环境要求较高

##### 原理：

当磁头和磁性记录介质有相对运动时，通过电磁转换完成读/写操作。

编码方法：按某种方案（规律），把一连串的二进制信息变换成存储介质磁层中一个磁化翻转状态的序列，并使读/写控制电路容易、可靠的实现转换。

磁记录方式：通常采用调频制（FM）和改进型调频制（MFM）的记录方式。



外存储器既可以作为输入设备，也可以作为输出设备。（既可以存数据，也可以读数据）



#### 磁盘存储器

##### 磁盘设备的组成

1. 存储区域

   一块硬盘含有若干个记录面，每个记录划分为若干条磁道，而每条磁道又划分为若干个扇区，扇区（也称块）是磁盘读写的最小单位，也就是说磁盘按块存取。

   磁头数（Heads）：即记录面数，表示硬盘总共有多少个磁头，磁头用于读取/写入盘片上记录面的信息，一个记录面对应一个磁头。

   柱面数（Cylinders）：表示硬盘每一面盘片上有多少条磁道。在一个盘组中，不同记录面的相同编号（位置）的诸多磁道构成一个圆柱面。

   扇区数（Sectors）：表示每一条磁道上有多少个扇区。

2. 硬盘存储器

   硬盘存储器由磁盘驱动器、磁盘控制器和盘片组成。

   

磁盘驱动器：核心部件是刺头组件和盘片组件，温彻斯特盘是一种可移动固定盘片的硬盘存储器。

磁盘控制器：是硬盘存储器和主机的接口，主流标准有IDE、SCSI、SATA等。



##### 磁盘的性能指标

1. 磁盘的容量

   一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。

   非格式化容量是指磁记录表面可以利用的磁化单元总数。

   格式化容量是指按照某种特定的记录格式所能存储信息的总量。

2. 记录密度

   记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。

   道密度：是沿磁盘半径方向单位长度上的磁道数

   位密度：是磁道单位长度上能记录的二进制代码位数

   面密度：是位密度和道密度的乘积

   注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同。

3. 平均存取时间

   平均存取时间 = 寻道时间（磁头移动到目的磁道）+

   ​							旋转延迟时间（磁头定位到所在扇区）+

   ​							传输时间（传输数据所花费的时间）

4. 数据传输率

   磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。

   假设磁盘转数为r（转/秒），每条磁道容量为N个字节，则数据传输率为D<sub>r</sub> = rN

   

##### 磁盘地址

主机向磁盘控制器发送寻址信息，磁盘的地址一般如图所示：

| 驱动器号 | 柱面（磁道）号 | 盘面号 | 扇区号 |
| -------- | -------------- | ------ | ------ |

若系统中有4个驱动器，每个驱动器带一个磁盘，每个磁盘256个磁道、16个盘面，每个盘面划分为16个扇区，则每个扇区地址要18位二进制代码。

| 驱动器号（2bit） | 柱面（磁道）号（8bit） | 盘面号（4bit） | 扇区号（4bit） |
| ---------------- | ---------------------- | -------------- | -------------- |



##### 硬盘的工作过程

硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。

硬盘属于机械式部件，其读写操作是串行的，不可能在同一时刻既读又写，也不可能在同一时刻读两组数据或写两组数据。



#### 磁盘阵列

RAID（廉价冗余磁盘阵列）是将多个独立的物理磁盘组成一个独立的逻辑盘，数据在多个物理盘上交叉存储、并行访问，具有更好的存储性能、可靠性和安全性。

RAID的分级如下所示。在RAID～RAID5的几种方案中，无论何时有磁盘损坏，都可以随时拔出受损的磁盘再插入好的磁盘，而数据不会损坏。

- RAID0：无冗余和无校验码的磁盘阵列

  RAID0把连续多个数据块交替的存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度，单RAID0没有容错能力。

- RAID1：镜像磁盘阵列

  RAID1是为了提高可靠性，使两个磁盘同时进行读写，互为备份，如果一个磁盘出现故障，可从另一个磁盘中读出数据。两个磁盘当一个磁盘使用，意味着容量减少一半。

- RAID2：采用纠错的海明码的磁盘阵列

- RAID3：位交叉奇偶校验的磁盘阵列

- RAID4：块交叉奇偶校验的磁盘阵列

- RAID5：无独立校验的奇偶校验磁盘阵列

RAID通过同时使用多个磁盘，提高传输率；通过在多个磁盘上并行存取来大幅提高存储系统的存储数据吞吐量；通过镜像功能，可以提高安全可靠性；通过数据校验，可以提供容错能力。



#### 光盘存储器

光盘存储器是利用光学原理读/写信息的存储装置，它采用聚焦激光束对盘式介质以非接触的方式记录信息。

组成：

- 光盘片
- 光盘驱动器
- 光盘控制器
- 光盘驱动软件



特点：

- 存储密度高
- 携带方便
- 成本低
- 容量大
- 存储期限长
- 容易保存



光盘的类型如下：

- CD-ROM：只读型光盘，只能读出其中内容，不能写入或修改。
- CD-R：只可写入一次信息，之后不可修改。
- CD-RW：可读可写光盘，可以重复读写。
- DVD-ROM：容量高的CD-ROM，DVD表示通用数字化多功能光盘。



#### 固态硬盘

在微小高档笔记本电脑中，采用高性能Flash Memory作为硬盘来记录数据，这种“硬盘”称固态硬盘。

固态硬盘除了需要Flash Memory外，还需要其他硬件和软件的支持。

注：闪存（Flash Memory）是在E2PROM的基础上发展起来的，本质是只读存储器。



### I/O接口

#### I/O接口的功能

I/O接口（I/O控制）是主机和外设之间的交接界面，通过接口可以实现主机和外设之间的信息交换。

接口的功能：

- 设备选址
- 传送命令
- 传送数据
- 反映I/O设备的工作状态



#### I/O接口的基本结构

- 设备选择电路

- 命令寄存器和命令译码器

- 数据缓冲寄存器DBR

- 设备状态标记

  - 完成触发器D
  - 工作触发器B
  - 中断请求触发器INTR
  - 屏蔽触发器MASK

- 控制逻辑电路

- 内部接口

  内部接口与系统总线相连，实质上是与内存、CPU相连。数据的传输方式只能是并行传输。

- 外部接口

  外部接口通过接口电缆与外设相连，外部接口的数据传输可能是串行方式，因此I/O接口需具有串/并转换功能



CPU同外设之间的信息传送实质是对接口中的某些寄存器（即端口）进行读或写。如传送数据是对数据端口DBR进行读写操作。以控制外设输入为例：

1. 选择设备
2. 判断是否此设备
3. 反馈设备状态
4. 若设备已就绪，发送控制命令
5. 暂存命令并转换为外设的控制信号
6. 向外设发送控制命令
7. 输入数据
8. 完成输入
9. 反馈输入完成（中断请求）
10. 中断响应
11. 中断类型号
12. 取走数据



#### I/O端口

I/O端口是指接口电路中可以被CPU直接访问的寄存器。

- 数据端口：读或写
- 控制端口：写
- 状态端口：读



#### I/O端口及其编址

##### 统一编址

把I/O端口当作存储器的单元进行地址分配，用统一的访存指令就可以访问I/O端口，又称存储器映射方式。

靠不同的地址码区分内存和I/O设备，I/O地址要求相对固定在地址的某部分。

如系统总线中地址线共10根，则可以访问的存储单元个数为2<sub>10</sub>=1024个，假设要给10个I/O端口编址：

1. 0～9表示I/O地址，10～1023为主存单元地址
2. 0～1013表示主存单元地址，1014～1023为I/O地址
3. 10～19表示I/O地址，0～9、20～1023为主存单元地址

优点：

不需要专门的输入/输出指令，可使CPU访问I/O的操作更灵活、更方便，还可使端口有较大的编址空间。

缺点：

端口占用了存储器地址，使内存容量变小，而且，利用存储器编址的I/O设备进行数据输入/输出操作，执行速度较慢。



##### 独立编址

I/O端口地址与存储器地址无关，独立编址CPU需要设置专门的输入/输出指令访问端口，又称I/O映射方式。

靠不同的指令区分内存和I/O设备。

优点：

输入/输出指令与存储器指令有明显区别，程序编址清晰，便于理解。

缺点：

输入/输出指令少，一般只能对端口进行传送操作，尤其需要CPU提供存储器读/写、I/O设备读/写两组控制信号，增加了控制的复杂性。



#### I/O接口的类型

##### 按数据传送方式可分为

并行接口：一个字节或一个字所有位同时传送。

串行接口：一位一位的传送。

注：这里说的数据传送方式指的是外设和接口一侧的传送方式，二在主机和接口一侧，数据总是并行传送的。接口要完成数据格式转换。



##### 按主机访问I/O设备的控制方式可分为

程序查询接口

中断接口

DMA接口



##### 按功能选择的灵活性可分为

可编程接口

不可编程接口



### 程序查询方式
#### 执行流程

1. 预制传送参数

   CPU执行初始化程序，并预置传送参数--设置计数器、设置数据首地址

2. 启动外设

   向I/O接口发送命令字段，启动I/O设备

3. 取外设状态

   CPU从接口读取设备状态信息

4. 外设准备就绪？

   CPU不断查询I/O设备状态，直到外设准备就绪

   CPU一旦启动I/O，必须停止现行程序的运行，并在现行程序中插入一段程序。

   主要特点：CPU有“踏步”等待现象，CPU与I/O串行工作。

   Y：执行步骤5

   N：执行步骤3

5. 传送一次数据

   一般为一个字

6. 修改传送参数

   修改地址和计数器参数

7. 传送完成？

   判断传送是否结束（一般计数器为0时结束）

   Y：结束

   N：执行步骤3



优点：接口设计简单、设备量少

缺点：CPU在信息传送过程中要花费很多时间用于查询和等待，而且在一段时间内只能和一台外设交换信息，效率大大降低。



#### 接口结构

- 设备选择电路
- 数据缓冲寄存器DBR
- 设备状态寄存器



#### 例题

在程序查询方式的输入/输出系统中，假设不考虑处理时间，每一个查询操作需要100个时钟周期，CPU的时钟频率为50MHz。现有鼠标和硬盘两个设备，而且CPU必须每秒对鼠标进行30次查询，硬盘以32位字长为单位传输数据，即每32位被CPU查询一次，传输率为2x2<sub>20</sub>B/s。求CPU对这两个设备查询所花费的时间比率，由此可得出什么结论？

时间的角度：

一个周期为：1/50MHz = 20ns

一个查询操作耗时：100x20ns = 2000ns

1. 鼠标

   每秒查询鼠标耗时：30x2000ns = 60000ns

   查询鼠标所花费的时间比率：60000ns/1s = 0.00%

   对鼠标的查询基本不影响CPU的性能

2. 硬盘

   每32位需要查询一次，每秒传送：2x2<sup>20</sup>B

   每秒需要查询：(2x2<sup>20</sup>B)/32 = 2<sup>19</sup>次

   查询硬盘耗时：2<sup>19</sup>x2000ns = 512x1024x2000ns ≈ 1.05 x 10<sup>9</sup>ns

   查询硬盘所花费的时间比率：1.05 x 10<sup>9</sup>ns / 1s = 105%

   CPU将全部时间都用于对硬盘的查询也不能满足磁盘传输的要求。



频率的角度：

CPU的时钟频率为50MHz，即每秒50x10<sup>6</sup>个时钟周期

1. 鼠标

   每秒查询鼠标占用的时钟周期：30x100 = 3000

   查询鼠标所花费的时间比率：3000/(50x10<sup>6</sup>) = 0.00%

   对鼠标的查询基本不影响CPU的性能

2. 硬盘

   每秒需要查询：(2x2<sup>20</sup>B)/32 = 2<sup>19</sup>次

   每秒查询硬盘占用的时钟周期数：2<sup>19</sup>x100 ≈ 5.24x10<sup>7</sup>

   查询硬盘所花费的时间比率：(5.24x10<sup>7</sup>)/(5x10<sup>6</sup>) ≈ 105%

   CPU将全部时间都用于对硬盘的查询也不能满足磁盘传输的要求。



### 程序中断方式

#### 中断的基本概念

程序中断是指计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后CPU又自动返回到现行程序的断点处，继续执行原程序。



工作流程：

1. 中断请求

   中断源向CPU发送中断请求信号

2. 中断响应

   响应中断的条件

   中断判优：多个中断源同时提出请求时通过中断判优逻辑响应一个中断源。

3. 中断处理

   中断隐指令

   中断服务程序



#### 中断请求的分类

- 内中断（内部异常）

  信号来源自CPU内部

  - 陷阱、陷入（trp）

    有意为之的异常，如系统调用

  - 故障（fault）

    由错误条件引起的，可能被故障处理程序修复，如缺页

  - 终止（abort）

    不可恢复的致命错误造成的结果，终止处理程序不再将控制返回给引发终止的应用程序，如整数除0

- 外中断

  信号来源自CPU外部

  - I/O中断请求
  - 人工干预



#### 中断请求标记

每个中断向CPU发出中断请求的时间是随机的。

为了记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器INTR，当其状态为“1”时，表示中断源有请求。

这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。

| INTR<sub>1</sub> | INTR<sub>2</sub> | INTR<sub>3</sub> | INTR<sub>4</sub> | ... | INTR<sub>n-1</sub> | INTR<sub>n</sub> |
| ---------------- | ---------------- | ---------------- | ---------------- | --- | ------------------ | ---------------- |
| 0                | 0                | 0                | 1                | ... | 0                  | 1                |
| 掉电             | 过热             | 阶上溢           | 非法除法         | ... | 光电输入机         | 打印机输出机     |

对于外中断，CPU是在统一的时刻即每条指令执行阶段结束前向接口发出中断查询信息，以获取I/O的中断请求，也就是说，CPU响应中断的时间是在每条指令执行阶段的结束时刻。

对于执行时间很长的指令，可以在执行过程中设置若干个“查询断点”。



CPU响应中断必须满足以下3个条件：

- 中断源有中断请求
- CPU允许中断即开中断
- 一条指令执行完毕，且没有更紧迫的任务



#### 中断判优-实现

中断判优既可以用硬件实现，也可以用软件实现。

硬件实现是通过硬件排队器实现的，它既可以设置在CPU中，也可以分散在各个中断源中。

软件实现是通过查询程序实现的。



#### 中断判优-优先级设置

1. 硬件故障中断属于最高级，其次是软件中断
2. 非屏蔽中断优于可屏蔽中断
3. DMA请求优于I/O设备传送的中断请求
4. 高速设备优于低速设备
5. 输入设备优于输出设备
6. 实时设备优于普通设备



#### 中断处理过程-硬件向量法

由硬件产生向量地址，再由向量地址找到入口地址。



中断隐指令的主要任务：

1. 关中断

   在中断服务器程序中，为了保护中断现场（即CPU主要寄存器中的内容）期间不被新的中断所打断，必须关中断，从而保证被中断的程序在中断服务程序执行完毕之后能接着正确的执行下去。

2. 保存断点

   为了保证在中断服务程序执行完毕就能正确的返回到原来的程序，必须将原来程序的断点（即程序计数器（PC）的内容）保存起来。可以存入堆栈，也可以存入指定单元。

3. 引出中断服务程序

   引出中断服务程序的实质就是取出中断服务程序的入口地址并传送给程序计数器（PC）。

    

#### 中断处理过程-中断服务程序

中断服务程序的主要任务：

1. 保护现场

   1. 保护程序断点（PC），已由中断隐指令完成；
   2. 保存通用寄存器和状态寄存器的内容，由中断服务程序完成。

   可以使用堆栈，也可以使用特定存储单元

2. 中断服务（设备服务）

   主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲存储器中。

3. 恢复现场

   通过出栈指令或取数据指令把之前保存的信息送回寄存器中

4. 中断返回

   通过中断返回指令回到原程序断点处。



#### 单重中断与多重中断

单重中断：执行中断程序服务时不响应新的中断请求

多重中断：又称中断嵌套，执行中断服务程序时可响应新的中断请求

|              | 单重中断         | 多重中断         |
| ------------ | ---------------- | ---------------- |
| 中断隐指令   | 关中断           | 关中断           |
|              | 保存断点（PC）   | 保存断点（PC）   |
|              | 送中断向量       | 送中断向量       |
| 中断服务程序 | 保护现场         | 保护现场和屏蔽字 |
|              | -                | 开中断           |
|              | 执行中断服务程序 | 执行中断服务程序 |
|              | -                | 关中断           |
|              | 恢复现场         | 恢复现场和屏蔽字 |
|              | 开中断           | 开中断           |
|              | 中断返回         | 中断返回         |



#### 中断屏蔽技术

中断屏蔽技术主要用于多重中断，CPU要具备多重中断的功能，需满足以下条件。

1. 在中断服务程序中提前设置开中断指令
2. 优先级别高的中断源有权中断优先级别低的中断源

每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示可以正常申请，所有屏蔽触发器组合在一起，便构成一个屏蔽字寄存器，屏蔽字寄存器的内容称为屏蔽字。



屏蔽字设置的规律：

1. 一般用“1”表示屏蔽，“0”表示正常申请。
2. 每个中断源对应一个屏蔽字（在处理该中断源的中断服务程序时，屏蔽寄存器中的内容为该中断源对应的屏蔽字）。
3. 屏蔽字中“1”越多，优先级越高。每个屏蔽字中至少有一个“1”（至少要能屏蔽自身的中断）。



例题：设某机中4个中断源A、B、C、D，其硬件排队优先次序为A>B>C>D，现要求将中断处理次序改为D>A>C>B。

1. 写出每个中断源对应的屏蔽字。
2. 按下图所示的时间轴给出的4个中断源的请求时刻，画出CPU执行程序的轨迹。设每个中断源的中断服务程序时间均为20us。

解答：

1. 屏蔽字设计

   | 中断源 | A   | B   | C   | D   | 屏蔽字 |
   | ------ | --- | --- | --- | --- | ------ |
   | A      | 1   | 1   | 1   | 0   | 1110   |
   | B      | 0   | 1   | 0   | 0   | 0100   |
   | C      | 0   | 1   | 1   | 0   | 0110   |
   | D      | 1   | 1   | 1   | 1   | 1111   |

2. 略



### DMA方式

在程序中断方式中每准备好一个数据都要中断CPU，由CPU运行中断服务程序来完成一次传送，磁盘机、磁带机等高速设备需要大批量的数据传送，这会导致CPU大量时间用于中断服务，由此产生由硬件实现控制大批量的数据传送，DMA控制器。



在DMA方式中，当I/O设备需要进行数据传送时，通过DMA控制器（DMA接口）向CPU提出DMA传送请求，CPU响应之后将让出系统总线，由DMA控制器接管总线进行数据传送。其主要功能有：

1. 接受外设发出的DMA请求，并向CPU发出总线请求
2. CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期
3. 确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数
4. 规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作
5. 向CPU报告DMA操作的结束



#### DMA控制器的结构

- 控制/状态逻辑

  由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对DMA请求信号和CPU响应信号进行协调和同步

- DMA请求触发器

  每当I/O设备准备好数据后给出一个控制信号，使DMA请求触发器置位

- 数据缓冲寄存器

  用于暂存每次传送的数据

- 主存地址计数器

  简称AR，存放要交换数据的主存地址

- 传送长度计数器

  简称WC，用来记录传送数据的长度，技术溢出时，数据即传送完毕，自动发中断请求信号。

- 中断机构

  当一个数据块传送完毕后触发中断机构，向CPU提出中断请求

注：在DMA传送过程中，DMA控制器将接管CPU地址总线、数据总线和控制总线，CPU的主存控制信号被禁止使用。而当DMA传送结束后，将恢复CPU的一切权利并开始执行其操作。



#### DMA传送过程

CPU：

- 预处理
  - 主存起始地址 &rarr; AR
  - I/O设备地址 &rarr; DAR
  - 传送数据个数 &rarr; WC
  - 启动I/O设备
- 数据传送
  - 继续执行主程序
  - 同时完成一批数据的传送
- 后处理
  - 中断服务程序
  - 做DMA结束处理
- 继续执行主程序



数据传送阶段的细化：

DMA请求

1. 允许传送？

   N：执行步骤1

   Y：执行步骤2

2. 主存起始地址送到总线，数据送到I/O设备（或主存），修改主存地址，修改字计数器

3. 数据块传送结束？

   N：执行步骤1

   Y：执行步骤4

4. 向CPU申请程序中断



#### DMA传送方式

主存和DMA控制器之间有一条数据通路，因此主存和I/O之间交换信息时，不通过CPU。但当I/O设备和CPU同时访问主存时，可能冲突，为了有效使用主存，DMA控制器与CPU通常采用以下3种方法使用主存。

1. 停止CPU访问主存

   优点：控制简单

   缺点：CPU处于不工作状态或保持状态，未充分发挥CPU对主存的利用率

2. DMA与CPU交替访存

   优点：不需要总线使用权的申请、建立和归还过程

   缺点：硬件逻辑更为复杂

3. 周期挪用（周期窃取）

   DMA访问主存有三种可能：

   - CPU此时不妨存（不冲突）
   - CPU此时正在访存（存取周期结束让出总线）
   - CPU与DMA同时请求访存（I/O访存优先）



#### DMA方式的特点

主存和DMA接口之间有一条数据通路。

由于DMA方式传送数据不需要经过CPU，因此不必中断现行程序，I/O与主机并行工作，程序和传送并行工作。

DMA方式具有下列特点：

- 它使主存与CPU的固定联系脱钩，主存既可被CPU访问，又可被外设发访问
- 在数据块传送时，主存地址的确定、传送数据的计数等都由硬件电路直接实现
- 主存中要开辟专用缓冲区，及时供给和接收外设的数据
- DMA传送速度快，CPU和外设并行工作，提高了系统效率
- DMA在传送开始前要通过程序进行预处理，结束后要通过中断方式进行后处理



#### DMA方式与中断方式

|          | 中断                                       | DMA                                               |
| -------- | ------------------------------------------ | ------------------------------------------------- |
| 数据传送 | 程序控制，程序的切换 &rarr; 保存和恢复现场 | 硬件控制，CPU只需进行预处理和后处理               |
| 中断请求 | 传送数据                                   | 后处理                                            |
| 响应     | 指令执行周期结束后响应中断                 | 每个机器周期结束后均可，总线空闲时即可响应DMA请求 |
| 场景     | CPU控制，低速设备                          | DMA控制器控制，高速设备                           |
| 优先级   | 优先级低于DMA                              | 优先级高于中断                                    |
| 异常处理 | 能处理异常事件                             | 仅传送数据                                        |



#### CPU占用情况

某计算机的CPU主频为500MHz，CPI为5（即执行每条指令平均需要5个时钟周期）。假定某外设的数据传输率为0.5MB/s，采用中断方式与主机进行数据传送，以32位为传输单位，对应中断服务程序包含18条指令，中断服务外的其他开销相当于2条指令的执行时间。请回答下列问题，要求给出计算过程。

1. 在中断方式下，CPU用于该外设I/O的时间占整个CPU时间的百分比是多少？

   每传送一次数据，占用CPU的时间为：(18+2)x5 = 100个时钟周期

   外设准备32位的数据需要的时间为：32bit ÷ 0.5MB/s = 8 x 10<sup>-6</sup>s

   每秒可准备的数据个数为：1s ÷ 8 x 10<sup>-6</sup>s = 125000个

   即每秒需中断的次数为125000次

   则1s内用于处理中断的时钟周期数（开销）为：125000 x 100 = 12.5M个

   故CPU用于外设I/O的时间占整个CPU时间的百分比为：12.5M ÷ 500M = 2.5%

   若外设速度达到5MB/s，则故CPU用于外设I/O的时间占整个CPU时间的百分比为：25%

2. 当该外设的数据传输率达到5MB/s时，改用DMA方式传输数据。假定每次DMA传送块大小为5000B，且DMA预处理和后处理的总开销为500个时钟周期，则CPU用于该外设I/O的时间都百分比是多少？（假设DMA与CPU之间没有访存冲突）

   当外设数据传输率提高到5MB/s时改用DMA方式传送，每次DMA传送一个数据块，大小为5000B，则1s内需产生的DMA次数为：5MB ÷ 5000B = 1000次

   CPU用于DMA处理的总开销为1000 x 500 = 0.5M个时钟周期

   CPU用于外设I/O的时间占整个CPU时间的百分比为：0.5M ÷ 500M = 0.1%







