---
title: 软件工程
date: 2022-9-24
tags:
  - 网课
category: 计算机
banner: /img/banner/62.jpeg
---


# 软件工程

别人的笔记：https://gitee.com/fakerlove/software-engineering



1.3 软件种类

系统、支撑、应用软件



2.0 三个阶段

个人程序时期

软件作坊时期

软件工程时期

1968年



Model模型：抽象描述

软件工程三元组：目标、原则、活动



2.1 软件工程生存周期

过程、活动、任务

2.1.1基本过程

  获取过程

  供应过程

  管理过程

  运行过程

  开发过程

  维护过程

2.1.2 支持过程

2.1.3 组织过程



2.2 生存周期模型：是一种组织结构

2.2.1 瀑布模型：自下而上线性，需求必须明确

2.2.2 瀑布模型：自下而上或反之

2.2.3 增量模型：先开发出核心版本，后续增加需求，前提核心需求明确

例子：

微软“同步-稳定的产品开发模型”

设定里程碑阶段 -> 定义稳定、灵活的体系结构 -> 开发构件、维持一个可发布的系统版本

2.2.4 演化模型：弹性的过程模式，先开发核心需求，获取用户反馈，实施后续迭代，具有需求不能确定特征

2.2.5 喷泉模型：

2.2.6 螺旋模型：与演化模型类似，但加入了风险分析

2.2.7 快速原型模型：适合小项目，快速开发的项目

2.2.8 面向复用的软件开发模型：节省成本，提高效率



3.0 软件需求及系统/产品（需求）规约

3.1 如何认识

3.1.1 设计约束

3.1.2 需求发现

- 自悟
- 交谈
- 观察
- 小组会



3.1.3 需求规约

Software requirements specification 软件需求说明

草案（SRS）：IEEE 830标准

1、引言

> 目的，范围，定义、缩略图、参考文献、概述

2、总体描述

> 产品表述、产品功能、用户特性、约束、假设和依赖

3、特定需求

> 需求中最重要的，之前都是高帽子。

4、附录

5、 索引

​	

4.结构化分析

结构化分析(Structured Analysis，简称SA 法)是**面向数据流的需求分析方法**

分解：是指对于一个复杂的系统，为了将复杂性降低到可以掌握的程度，可以把大问题分解成若干小问题，然后分别解决。

抽象：分解可以分层进行，即先考虑问题最本质的属性，暂把细节略去，以后再逐层添加细节，直至涉及到最详细的内容，这种用最本质的属性表示一个自系统的方法就是“抽象“

### 结构化分析所使用的工具

- 数据流图(Data Flow Diagram，DFD)
- 数据字典(DataDictionary，DD)
- 结构化语言
- 判定表
- 判定树



4.1.1 数据流图（DFD图）

需求分析的输出

xxx系统需求规格说明书

1.引言 

1.1编写目的

​	说明编写本需求规格说明书的目的

1.2背景说明

- 给出待开发的软件产品名称
- 说明本项目的提出者、开发者及用户
- 说明该软件产品将做什么，如有必要，说明不做什么。

1.3术语定义

1.4参考文献

2.概述

2.1功能概述

叙述待开发软件产品将完成的主要功能。

2.2约束

叙述对系统设计产生影响的限制条件，并对下一节中所述的某些特殊需求提供理由，如管理模式、硬件限制、安全等。

3.数据流图与数据字典及加工说明

3.1数据流图

3.1.1数据流图1

- 画出该数据流图
- 加工说明
- 数据流说明

3.1.2数据流图2

3.2数据字典

3.2.1文件说明

3.2.2数据项说明

4.接口

4.1用户接口

4.2硬件接口

4.3软件接口

5.性能需求

5.1精度

逐项说明对各项输入数据和输出数据达到的精度

5.2时间特征

定量说明本软件的时间特征，如响应时间、更新处理时间、数据传输、转换时间、计算时间等。

5.3灵活性

说明本软件所具有的灵活性，即当用户需求有某些变化时（如操作方式、运行换几个、时间特征等），本软件的适应能力。

6.属性

6.1可使用性

规定某些需求，如检验点、恢复方式和重启动性，以确保软件可使用。

6.2保密性

规定保护软件的要素

6.3可维护性

6.4可移植性

7.其他需求

7.1数据库

7.2操作

7.3故障及处理



5.结构化设计

模块

调用

模块化

高内聚，低耦合



5.x详细设计



5.x软件设计评审

详细设计走查



6.敏捷软件开发（Agile Develpment）

6.1概念

应对快速变化的需求

哲学理念和一系列开发指南的综合



6.2敏捷联盟

宣言：

个体交互胜过过程和工具

可以工作的软件胜过面面俱到的文档

客户合作胜过合同谈判

响应变化胜过遵循计划



6.3敏捷原则

12条原则

- 我们最重要的目标，是通过及早和持续不断地交付有价值的软件使客户满意。

- 欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。

- 经常地交付可工作的软件，相隔几星期或一两个月，倾向于采取较短的周期。

- 业务人员和开发人员必须相互合作，项目中的每一天都不例外。

- 激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以信任，从而达成目标。

- 不论团队内外，传递信息效果最好效率也最高的方式是面对面的交谈。

- 可工作的软件是进度的首要度量标准。

- 敏捷过程倡导可持续开发。责任人、开发人员和用户要能够共同维持其步调稳定延续。

- 坚持不懈地追求技术卓越和良好设计，敏捷能力由此增强。

- 以简洁为本，它是极力减少不必要工作量的艺术。

- 最好的架构、需求和设计出自自组织团队。

- 团队定期地反思如何能提高成效，并依此调整自身的行为表现。



6.4 极限编程

极限编程（ExtremeProgramming，简称XP）是由KentBeck在1996年提出的，是一种[软件工程](https://baike.baidu.com/item/软件工程/16352442?fromModule=lemma_inlink)方法学，是[敏捷软件开发](https://baike.baidu.com/item/敏捷软件开发/7108658?fromModule=lemma_inlink)中可能是最富有成效的几种方法学之一。如同其他敏捷方法学，极限编程和传统方法学的本质不同在于它更强调可适应性能性以及面临的困难。1996年三月，Kent终于在为DaimlerChrysler所做的一个项目中引入了新的软件开发观念——XP。适用于小团队开发。



6.4.1极限编程实践

**1. 完整团队:**
  XP项目的所有参与者（开发人员、业务分析师、测试人员等等）一起工作在一个开放的场所中，他们是同一个团队的成员。这个场所的墙壁上随意悬挂着大幅的、显著的图表以及其他一些显示他们进度的东西。

**2. 计划游戏:**
  计划是持续的、循序渐进的。每2周，开发人员就为下2周估算候选特性的成本，而客户则根据成本和商务价值来选择要实现的特性。

**3. 客户测试:
**  作为选择每个所期望的特性的一部分，客户定义出自动验收测试来表明该特性可以工作。

**4. 简单设计:**    
  团队保持设计恰好和当前的系统功能项匹配。它通过了所有的测试，不包含任何重复，表达出了编写者想表达的所有东西，并且包含尽可能少的代码。

**5. 结对编程:**
  所有的产品软件都是由两个程序员、并排坐在一起在同一台机器上构建的。
    
**6. 测试驱动开发:**
  程序员以非常短的循环周期工作，他们先增加一个失败的测试，然后使之通过。

**7. 改进设计:**
  随时改进糟糕的代码。保持代码尽可能的干净、具有表达力。

**8. 持续集成:**
  团队总是是系统完整的被集成。

**9. 集体代码所有权:**
  任何结对的程序员都可以在任何时候改进任何代码。

**10.编码标准:**
  系统中所有的代码看起来就好像是被单独一个——非常胜任的——人编写的。

**11.隐喻：**
  团队提出一个程序工作原理的公共景象。

**12.可持续的速度：
**  团队只有持久才有获胜的希望。他们以能够长期维持的速度努力工作。他们保存精力，他们把项目看作是马拉松长跑，而不是全速短跑。

**13 重构**



6.4.2极限编程过程

#### 1.用户故事：

用户故事由客户编写，是站在用户角度描述具体的期望需求。它不局限于只描述用户界面，还推动了验收测试的创建。开发过程中，团队必须创建一个或多个自动接受测试，以验证产品是否正确实施了用户案例。



用户故事不宜过大。每个故事的“理想开发时间”分别为1、2或3周，理想的开发时间是在团队没有正在进行的其他任务，没有干扰，并且有明确计划的情况下用代码实现用户故事所需的时间。



#### 2.spike方案架构：

当团队开发过程中遇到棘手的技术或者技术问题的时候，需要创建一个spike解决方案。



spike解决方案是一个非常简单的程序，通过构建峰值来解决正在检查的问题。因此团队往往将它用于探索潜在的解决方案，以降低技术问题的风险或增加用户故事估算的可靠性。



#### 3.发布计划：

该计划对整个项目进行总体布局，再为每个迭代周期创建迭代计划，其实质是让开发团队根据理想的编程周来评估每个用户故事。



发布计划的基本原理是，一个项目可以通过四个变量来量化。范围、资源、时间和质量：范围是要完成的工作量；资源是多少有空的人；时间是项目或发布完成的时间；质量是软件的质量以及测试的质量。没有人可以控制所有4个变量，当一个变量改变时，其他三个都会随之变化。因此，发布计划会议中最重要的是，客户、经理、开发团队需要协商出一个可接受的发布计划，然后在执行计划中合理地控制变量以达到理想效果。



#### 4.迭代开发：

极限编程将复杂的开发过程分解成一个个小的开发周期，对需求分析、设计、编码、测试进行反复迭代。每个迭代周期为1到3周，在每次迭代开始都召开一次迭代会议，计划要完成的工作，及时调整工作规划。



在每个开发周期中，通过客户、业务人员和开发人员的交流、反馈能够清楚地发现软件开发过程中现存的问题并进行及时调整。另外，极限编程还要求将每次迭代看作最后一次迭代，团队中每个人都要时刻为按时交付产品做好准备。



#### 5.验收测试：

在迭代过程中，迭代计划会议期间选择的用户案例将转换为验收测试。该客户指定测试场景，以验证用户故事是否被正确执行。



每个验收测试代表系统的预期结果。客户负责验证验收测试的正确性，并检查测试分数，以确定哪些失败的测试需要优先进行调整。在最终产品发布之前，验收测试还用作回归测试。

此外，每个迭代中都要创建验收测试，只有通过了验收测试才能进行迭代的交付，否则进度依然为零。



#### 6.频繁发布小版本：

及时获得有价值的反馈对系统的开发产生影响是至关重要的，因此开发团队需要经常向客户发布系统的迭代版本。在每次迭代的最后，都将进行小版本测试，运行且可生产的准备就绪的软件可以向客户展示，由此决定是否将其投入生产。



极限编程重视客户反馈，目的是满足客户需要，强调团队合作：管理层、客户和开发人员都是开发团队中的一员。在整个流程中，最终产品的顺利交付是各个环节相互叠加的成果，少不了参与其中的各个成员的努力。只有团队成员通过相互之间充分的交流和合作，才能真正开发出简单、高效的软件。





6.4.3 scrum开发流程

Scrum将整个开发过程分为多次迭代（称为Sprint，冲刺），一般为期2～4周，最常见的为2周。Scrum并非以一段时间集中完成一个过程，而是将所有过程中必须的每一部分集中在这段时间内完成。需求、设计、编码、测试、上线都必须在一个迭代中完成，每个迭代必须产生一个可以工作的软件。



7.面向对象

7.1面向对象方法

####  OOD 法

Object-Oriented Design

在需求分析的基础上，进一步解决“如何作”的问题，OOD 法也分为概要设计和详细设计。 概要设计：细化对象行为，添加新对象，认定类，组类库，确定外部接口及主要数据结构 详细设计：加细对象描述

#### OOP 法

Object-oriented programming

使用面向对象的程序设计语言，如C++进行程序设计。 　　Coad和Yourdon给出一个面向对象的定义： 　　面向对象=对象+类+继承+消息 　　如果一个软件系统是按照这样四个概念设计和实现的，则可以认为这个软件系统是面向对象的。



#### OOA法

Object-Oriented Analysis

就是要解决“做什么”的问题。OOA 法的基本任务就是要建立三种模型：

##### 对象模型（信息模型）

定义构成系统的类和对象，它们的属性与操作。

##### 状态模型（动态模型）

- 描述任何时刻对象的联系及其联系的改变，即时序。常用状态图, 事件追踪图描述。
- 功能模型（函数模型）
- 描述系统内部数据的传送处理。

显然，在三大模型中，最重要的是对象模型。



#### UML法

https://www.visual-paradigm.com/cn/guide/uml-unified-modeling-language/what-is-uml/



**统一建模语言**（英语：Unified Modeling Language，缩写**UML**）是非专利的第三代[建模](https://zh.wikipedia.org/wiki/建模语言)和[规约语言](https://zh.wikipedia.org/wiki/规约语言)。UML是一种开放的方法，用于说明、可视化、构建和编写一个正在开发的、面向对象的、软件密集系统的制品的开放方法。UML展现了一系列最佳工程实践，这些最佳实践在对大规模，复杂系统进行建模方面，特别是在[软件架构](https://zh.wikipedia.org/wiki/软件架构)层次已经被验证有效。

在UML系统开发中有三个主要的模型：

- **功能模型**：从用户的角度展示系统的功能，包括用例图。
- **对象模型**：采用对象，属性，操作，关联等概念展示系统的结构和基础，包括类别图、对象图。
- **动态模型**：展现系统的内部行为。包括序列图，活动图，状态图。



### 一种软件开发方法学至少由3部分组成

- 用于表达基本信息的术语。
- 用于组织基本信息的表达格式。
- 在不同抽象层之间进行映射的过程指导。

### UML解决的问题

- 提供8个术语，用于抽象表达客观世界中各式各样的事物。
- 提供4个术语，用于抽象表达客观世界中各式各样事物之间的关系。
- 提供4种工具，用于抽象表达客观世界中各种系统的模型。

### 表达客体的术语

1.类与对象 (class and object)

类是一组具有相同属性、操作、关系和语义的对象的描述，对象是类的一个实例。通常把类表示为具有3个栏目的矩形，每个栏目分别代表类名、属性和操作。
 类可以是抽象类，即没有实例的类，其类名采用斜体字表示。
 类体现了数据抽象、过程抽象、局部化以及信息隐蔽等原理。类与对象的变体可以是参与者(Actor)。

2.接口(interface)

接口是操作的一个集合，其中每一个操作描述了类、构件或子系统的一个服务。接口根据需求，可以分为供接口与需接口，用于表示提供服务和需要服务。小圆圈表示提供服务，就是需要去实现，半圆圈表示需求服务，就是要别人实现。

接口对系统中的“接缝”予以模型化。也就是说，通过声明一个接口，表明一个类、构件、子系统为其它类、构件、子系统提供了所需要的、且与实现无关的行为，或表明一个类、构件、子系统所要得到的、且与实现无关的行为。

3. 协作(collaboration)

协作是一个交互，涉及交互的三个要素：交互各方、交互方式以及交互内容。在UML中，协作表示为虚线椭圆。

协作可以表现系统实现的一种构成模式。

4. 用况(use case)

用况是对一组动作序列的描述，系统执行这些动作应产生对特定参与者有值的、可观察的结果。在UML中，用况用实线椭圆表示。

在系统建模中，用况一般用于模型化系统中功能行为，是建立系统功能模型的一个重要术语。并且，由用况表达的系统，往往可以通过协作予以精化。

5. 主动类(active class)

主动类是一种至少具有一个进程或线程的类。其对象行为通常是与其他元素行为并发的。主动类的表示与类相似，只是多了两条竖线。

在系统建模中，主动类一般用于模型化系统中的并发行为。它的变体是进程和线程。

6. 构件(component)

构件是系统设计中的一个模块化组件，通过外部接口隐藏它的内部实现。构件一般用于表达解空间中可独立标识的成分。换言之，构件不能用于问题定义。

7. 制品(artifact)

制品是系统中包含物理信息的、可替代的物理部件。常用于代表有关源代码信息或运行时信息的一个物理打包，因此在一个系统中，可能存在不是类型的部署制品，例如源代码、可执行程序和脚本。可见，它的变体可以是应用、文档、库、页、表。

8. 节点(node)

节点是在运行时存在的物理元素，通常表示一种具有记忆能力和处理能力的计算机资源。

UML把这8个术语统称为类目。用于描述客体。



### 表达客体关系的术语

https://researchlab.github.io/2016/11/23/uml-symbol-desc/

为了表达各类事物之间的相互依赖和作用，UML给出了4个术语：关联、泛化、细化、依赖。

由上述四类图形（`线`，`箭头`,`三角`,`菱形`)可构成以下类图中六类常用关系,

1. `虚线+箭头`是表示即`依赖`的关系;
2. `实线+箭头`表示`关联`的关系;
3. `虚线+空心右三角`表示`实现`接口;
4. `实线+空心右三角`表示的是`泛化`，即`类的继承关系`;
5. `实线+空心菱形`表示的是`聚合`的关系;
6. `实线+实心菱形`则表示`组合`的关系。

